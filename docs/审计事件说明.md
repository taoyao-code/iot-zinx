# 充电流程审计事件说明

## 概述

审计事件是IoT-Zinx系统中记录设备操作、状态变化和业务流程的核心机制。通过完整的事件记录，系统能够提供故障排查、业务分析、合规审计和性能监控等关键能力。

## 审计事件的核心作用

### 1. 🔍 故障排查和问题定位

**场景**: 当充电桩出现异常时，需要快速定位问题原因

**审计事件的价值**:
- **完整的操作序列**: 记录设备从上线到故障的完整操作历史
- **状态变化追踪**: 追踪端口状态、设备状态的每次变化
- **协议交互记录**: 记录所有协议命令和响应，便于调试通信问题
- **时间线重建**: 按时间顺序重建事件发生的完整过程

**示例**:
```
时间线: 设备04A228CD端口1故障排查
14:30:01 - 设备上线事件
14:30:05 - 端口状态: 空闲 → 有充电器连接
14:30:10 - 充电开始事件
14:32:15 - 功率数据异常 (功率突降到0W)
14:32:20 - 端口状态: 充电中 → 故障状态
14:32:25 - 充电结束事件 (停止原因: 负载过大)
```

### 2. 📊 业务数据分析

**场景**: 运营团队需要分析充电桩使用情况和收入数据

**审计事件的价值**:
- **使用率统计**: 分析设备和端口的使用频率
- **收入分析**: 统计充电费用、电量消耗等财务数据
- **用户行为分析**: 分析用户充电习惯和偏好
- **设备性能评估**: 评估设备稳定性和效率

**示例分析**:
```sql
-- 基于审计事件的业务分析示例
-- 设备使用率分析
SELECT device_id, 
       COUNT(*) as session_count,
       AVG(duration) as avg_duration,
       SUM(total_energy) as total_energy
FROM charging_sessions 
WHERE start_time >= '2024-01-01'
GROUP BY device_id;

-- 故障率分析
SELECT device_id,
       COUNT(CASE WHEN event_type = 'charging_error' THEN 1 END) as error_count,
       COUNT(CASE WHEN event_type = 'charging_start' THEN 1 END) as total_sessions,
       ROUND(error_count * 100.0 / total_sessions, 2) as error_rate
FROM audit_events
GROUP BY device_id;
```

### 3. 🛡️ 合规审计和监管要求

**场景**: 满足政府监管和企业内部审计要求

**审计事件的价值**:
- **操作可追溯**: 每个操作都有完整的记录和时间戳
- **数据完整性**: 确保业务数据的完整性和一致性
- **权限审计**: 记录谁在什么时间进行了什么操作
- **合规报告**: 生成符合监管要求的审计报告

### 4. 🔧 系统性能监控

**场景**: 监控系统性能和健康状态

**审计事件的价值**:
- **响应时间监控**: 监控协议处理和业务操作的响应时间
- **吞吐量统计**: 统计系统处理的事件数量和频率
- **异常检测**: 及时发现异常模式和潜在问题
- **容量规划**: 基于历史数据进行容量规划

## 审计事件类型详解

### 设备生命周期事件

| 事件类型 | 描述 | 关键数据 | 业务价值 |
|---------|------|----------|----------|
| `device_online` | 设备上线 | IP地址、版本号、连接时间 | 监控设备可用性 |
| `device_offline` | 设备离线 | 离线原因、持续时间 | 分析设备稳定性 |
| `device_heartbeat` | 设备心跳 | 端口状态、设备状态 | 实时状态监控 |
| `time_sync` | 时间同步 | 服务器时间、设备时间差 | 确保时间准确性 |

### 充电流程事件

| 事件类型 | 描述 | 关键数据 | 业务价值 |
|---------|------|----------|----------|
| `charger_connected` | 充电器插入 | 端口号、检测时间 | 用户行为分析 |
| `charging_start` | 充电开始 | 订单号、用户ID、卡号 | 业务流程追踪 |
| `charging_progress` | 充电进度 | 功率、电量、温度 | 实时监控 |
| `charging_end` | 充电结束 | 停止原因、总电量、费用 | 结算数据 |
| `charger_disconnected` | 充电器拔出 | 拔出时间、最终状态 | 完整流程记录 |

### 业务流程事件

| 事件类型 | 描述 | 关键数据 | 业务价值 |
|---------|------|----------|----------|
| `user_auth` | 用户认证 | 卡号、认证方式、结果 | 安全审计 |
| `charging_control` | 充电控制 | 控制命令、参数、结果 | 操作审计 |
| `settlement` | 结算处理 | 电量、费用、支付方式 | 财务对账 |
| `fee_calculation` | 费用计算 | 计费规则、费用明细 | 计费审计 |

### 故障和异常事件

| 事件类型 | 描述 | 关键数据 | 业务价值 |
|---------|------|----------|----------|
| `device_error` | 设备故障 | 错误代码、故障描述 | 故障分析 |
| `port_error` | 端口故障 | 端口号、故障类型 | 维护管理 |
| `communication_error` | 通信异常 | 协议错误、重试次数 | 网络诊断 |
| `business_error` | 业务异常 | 业务错误、影响范围 | 业务监控 |

## 审计事件的数据结构

```go
type AuditEvent struct {
    EventID         string                 // 事件唯一标识
    EventType       string                 // 事件类型
    Timestamp       time.Time              // 事件时间戳
    DeviceID        string                 // 设备ID
    PortNumber      int                    // 端口号
    ProtocolCommand byte                   // 协议命令
    OldStatus       int                    // 原状态
    NewStatus       int                    // 新状态
    Data            map[string]interface{} // 事件数据
    Description     string                 // 事件描述
    SessionID       string                 // 关联的充电会话ID
}
```

## 审计事件的存储策略

### Redis存储结构

```
# 按设备和日期分组存储
Key: audit:events:{deviceID}:{date}
Type: List
TTL: 30天
Value: JSON格式的事件数据

# 事件类型索引
Key: audit:events:types:{eventType}
Type: Set
Value: 事件ID集合
```

### 数据保留策略

- **充电会话**: 90天（业务对账需要）
- **审计事件**: 30天（故障排查需要）
- **通知日志**: 7天（通信监控需要）

## 审计事件的查询和分析

### 常用查询场景

1. **按设备查询事件**
```go
events, err := auditService.GetEventsByDevice("04A228CD", startTime, endTime)
```

2. **按会话查询事件**
```go
events, err := auditService.GetEventsBySession(sessionID)
```

3. **按事件类型统计**
```go
count, err := auditService.GetEventCount("charging_error", startTime, endTime)
```

### 性能优化

- **批量写入**: 事件批量写入Redis，提高写入性能
- **异步处理**: 事件记录不阻塞主业务流程
- **索引优化**: 按设备、日期、事件类型建立索引
- **数据压缩**: 使用JSON压缩减少存储空间

## 监控和告警

### 关键指标

- **事件处理延迟**: 事件从产生到存储的时间
- **事件丢失率**: 因队列满或其他原因丢失的事件比例
- **存储使用率**: Redis存储空间使用情况
- **查询性能**: 事件查询的响应时间

### 告警规则

- 事件处理延迟 > 1秒
- 事件丢失率 > 0.1%
- 存储使用率 > 80%
- 查询响应时间 > 5秒

## 最佳实践

### 1. 事件设计原则

- **完整性**: 记录完整的上下文信息
- **一致性**: 使用统一的事件格式和命名规范
- **可读性**: 提供清晰的事件描述
- **可扩展性**: 支持未来的事件类型扩展

### 2. 性能优化

- **批量处理**: 批量写入事件，减少I/O开销
- **异步处理**: 使用队列异步处理事件
- **合理TTL**: 根据业务需求设置合理的数据保留时间
- **索引优化**: 为常用查询建立合适的索引

### 3. 安全考虑

- **敏感数据**: 避免在事件中记录敏感信息（如密码）
- **访问控制**: 限制审计数据的访问权限
- **数据加密**: 对敏感的审计数据进行加密存储
- **审计日志**: 对审计系统本身的操作也要进行审计

## 总结

审计事件是IoT-Zinx系统的重要组成部分，它提供了：

1. **完整的操作记录**: 为故障排查和问题定位提供详细信息
2. **业务数据支撑**: 为运营分析和决策提供数据基础
3. **合规审计能力**: 满足监管要求和内部审计需求
4. **系统监控手段**: 实时监控系统健康状态和性能

通过合理的事件设计、高效的存储策略和完善的查询机制，审计事件系统能够为IoT充电桩业务提供强有力的数据支撑和运维保障。
