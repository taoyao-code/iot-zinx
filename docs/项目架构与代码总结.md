# IoT-Zinx 项目架构与代码总结

## 1. 项目概述

IoT-Zinx 是一个基于 Zinx 网络框架的充电设备网关系统，实现了与充电桩设备的通信和管理。系统采用六边形架构（端口与适配器架构），实现了业务逻辑与技术实现的分离，提供了设备连接管理、心跳管理、刷卡消费、充电控制等功能。

### 1.1 主要功能

- **设备连接管理**：处理设备上线、注册和离线，支持 ICCID 和设备 ID 双重识别
- **多种心跳管理**：支持标准心跳、主机心跳、Link 心跳等多种保活机制
- **刷卡消费**：处理设备刷卡请求，验证卡片有效性并授权消费
- **充电控制**：向设备发送充电启停命令，控制充电过程
- **设备状态监控**：实时监控设备心跳状态，自动清理超时连接
- **服务器时间同步**：提供精准时间服务，确保设备与服务器时间同步
- **命令重发机制**：关键业务命令支持超时重发，确保命令可靠送达
- **原始数据记录**：完整记录设备与服务器之间的通信数据，便于问题排查

### 1.2 技术栈

- Go 语言开发
- Zinx 网络框架
- 六边形架构（端口与适配器架构）
- DNY 协议（设备通信协议）

## 2. 架构设计

项目采用六边形架构（端口与适配器架构），实现了业务逻辑与技术实现的分离：

### 2.1 核心架构组件

- **领域层** (`internal/domain`): 包含核心业务模型和协议定义
- **应用层** (`internal/app`): 包含业务服务实现
- **端口层** (`internal/ports`): 定义系统与外部交互的边界
- **适配器层** (`internal/adapter`): 实现与外部系统的交互
- **基础设施层** (`internal/infrastructure`): 提供技术支持
- **工具包层** (`pkg`): 重构后的可重用工具类集合

### 2.2 目录结构

```
iot-zinx/
├── cmd/                    # 可执行程序入口
│   ├── gateway/            # 网关程序
│   └── dny-parser/         # DNY协议解析工具
├── internal/               # 内部包
│   ├── app/                # 应用层代码
│   ├── domain/             # 领域层代码
│   ├── infrastructure/     # 基础设施层代码
│   └── ports/              # 接口层代码
├── pkg/                    # 可重用工具包
│   ├── protocol/           # DNY协议处理相关工具
│   ├── network/            # 网络通信相关工具
│   ├── monitor/            # 设备和连接监控工具
│   └── utils/              # 通用工具类
├── examples/               # 示例代码
└── docs/                   # 项目文档
```

## 3. 最近重构内容总结

### 3.1 重构目标与成果

项目最近进行了重构，主要目标是将工具类文件整理到`pkg`目录下，在不改变业务逻辑的情况下提高代码的模块化和可维护性。

#### 完成的重构工作

1. 分析并重组了原有的工具类文件结构
2. 创建了合理的目录结构用于组织工具类
3. 将原有功能迁移到新目录
4. 为每个模块定义了接口文件
5. 确保各个具体实现类实现了相应的接口
6. 创建了统一的导出接口和初始化机制
7. 更新了相关代码以使用新的工具类
8. 创建了兼容层使旧代码能够顺利过渡到新架构
9. 完善了文档，详细说明了各个模块的功能和使用方法

#### 重构的文件对应关系

| 旧文件                                                    | 新文件                            |
| --------------------------------------------------------- | --------------------------------- |
| `internal/infrastructure/zinx_server/packet.go`           | `pkg/protocol/dny_packet.go`      |
| `internal/infrastructure/zinx_server/raw_data_hook.go`    | `pkg/protocol/raw_data_hook.go`   |
| `internal/infrastructure/zinx_server/command_manager.go`  | `pkg/network/command_manager.go`  |
| `internal/infrastructure/zinx_server/heartbeat.go`        | `pkg/network/heartbeat.go`        |
| `internal/infrastructure/zinx_server/connection_hooks.go` | `pkg/network/connection_hooks.go` |
| `internal/infrastructure/zinx_server/raw_data_handler.go` | `pkg/network/raw_data_handler.go` |
| `internal/infrastructure/zinx_server/monitor.go`          | `pkg/monitor/tcp_monitor.go`      |
| `internal/infrastructure/zinx_server/device_monitor.go`   | `pkg/monitor/device_monitor.go`   |
| `internal/infrastructure/zinx_server/logger_adapter.go`   | `pkg/utils/logger_adapter.go`     |

### 3.2 重构优势

1. **模块化**: 将相关功能组织到不同的模块中，每个模块有明确的职责。
2. **接口隔离**: 通过接口定义明确了各个模块的功能边界。
3. **可测试性**: 接口化设计使得各个模块可以独立测试。
4. **可维护性**: 清晰的目录结构和命名约定使代码更易于维护。
5. **可扩展性**: 可以轻松添加新的实现而不影响现有代码。
6. **可复用性**: `pkg`目录中的代码可以被其他项目重用。

### 3.3 补充修复的问题

在进一步分析后，发现了额外的重复定义、重复解析和不统一使用的问题，并进行了修复：

#### 补充修复的重点问题

1. **debug/dny_parser.go 中的大量重复实现** ✅ 已修复

   - 删除了重复的 `getCommandName()`、`calculateChecksum()` 等函数
   - 删除了重复的 DNY 协议解析逻辑(169 行重复代码)
   - 删除了重复的十六进制处理函数

2. **不统一的 DNY 包头检查** ✅ 已修复

   - 替换了 4 处直接检查为统一的接口调用

3. **不统一的发送方式** ✅ 已修复

   - 统一使用 `conn.SendBuffMsg(0, data)` 方式

4. **额外的重复校验和函数** ✅ 已标记废弃
   - 统一使用 `pkg/protocol/dny_packet.go::CalculatePacketChecksum()` 接口

#### 修复统计

- 删除了总计约 320 行重复代码
- 100%的组件现在使用统一接口
- 职责分工明确，数据流程正确
- 11 个核心协议命令完整实现
- 统一的接口规范，易于扩展和维护

### 3.4 完全消除的重复问题

1. ✅ 重复的 DNY 协议解析函数 (3 处 → 1 处)
2. ✅ 重复的 DNY 协议构建函数 (3 处 → 1 处)
3. ✅ 重复的命令名称获取函数 (3 处 → 1 处)
4. ✅ 重复的校验和计算函数 (3 处 → 1 处主要接口)
5. ✅ 重复的协议解析器 (4 处 → 1 处)
6. ✅ 重复的 DNY 包头检查 (5 处 → 统一接口)

### 3.5 完全统一的使用方式

1. ✅ 协议解析: 统一使用 `protocol.ParseDNYData()`
2. ✅ 协议构建: 统一使用 `protocol.BuildDNYResponsePacket()`
3. ✅ 协议检查: 统一使用 `protocol.IsDNYProtocolData()`
4. ✅ 数据发送: 统一使用 `conn.SendBuffMsg()`
5. ✅ 命令名称: 统一使用 `protocol.GetCommandName()`

## 4. 核心功能组件

### 4.1 命令处理器

系统支持以下命令处理器：

- `DeviceRegisterHandler`：设备注册请求处理器 (0x20)
- `HeartbeatHandler`：标准心跳包处理器 (0x01)
- `MainHeartbeatHandler`：主机心跳包处理器 (0x11)
- `DeviceStatusHandler`：设备状态处理器 (0x21)
- `GetServerTimeHandler`：获取服务器时间处理器 (0x12/0x22)
- `SwipeCardHandler`：刷卡请求处理器 (0x02)
- `ChargeControlHandler`：充电控制处理器 (0x82)
- `ICCIDHandler`：ICCID 识别处理器
- `LinkHeartbeatHandler`：Link 心跳处理器
- `NonDNYDataHandler`：非 DNY 协议数据处理器
- `ParameterSettingHandler`：参数设置处理器
- `PowerHeartbeatHandler`：电源心跳处理器
- `SettlementHandler`：结算处理器

### 4.2 关键工具包组件

#### pkg/protocol 包

处理 DNY 协议相关的工具类：

- `dny_packet.go`: 实现 DNY 协议的封包和解包
- `raw_data_hook.go`: 处理原始数据发送和接收的钩子
- `interface.go`: 定义协议处理相关接口

#### pkg/network 包

处理网络通信相关的工具类：

- `command_manager.go`: 管理命令的发送、确认和重发
- `heartbeat.go`: 处理设备心跳相关功能
- `connection_hooks.go`: 处理连接建立和断开的钩子
- `raw_data_handler.go`: 处理原始数据

#### pkg/monitor 包

处理设备和连接监控的工具类：

- `tcp_monitor.go`: 监控 TCP 连接状态
- `device_monitor.go`: 监控设备状态和在线情况

#### pkg/utils 包

通用工具类：

- `logger_adapter.go`: 日志适配器，统一日志处理

### 4.3 设备连接生命周期

1. **连接建立**：设备与网关建立 TCP 连接，网关创建连接对象并分配连接 ID
2. **初始化识别**：设备可能发送 ICCID(SIM 卡号)或 Link 心跳等初始化数据
3. **设备注册**：设备发送注册请求(0x20)，网关解析设备信息并完成注册
4. **心跳保活**：设备定期发送心跳包(0x01/0x11/0x21)，网关更新设备状态
5. **业务交互**：设备发送业务请求(如刷卡 0x02)或网关下发控制命令(如充电控制 0x82)
6. **连接监控**：网关监控设备心跳状态，自动清理超时连接
7. **连接断开**：设备主动断开连接或网关检测到连接超时，释放连接资源

## 5. 协议支持

本系统实现了 DNY 协议（设备通信协议），支持以下功能：

1. 设备注册与认证
2. 心跳保活（设备心跳、主机心跳、Link 心跳等）
3. 刷卡消费
4. 充电控制
5. 设备状态监控
6. 服务器时间同步
7. 参数设置

### 5.1 协议格式

DNY 协议的基本格式为：

```
+--------+---------+--------+---------+------------+--------+--------+
| 包头   | 数据长度 | 物理ID | 消息ID  | 命令       | 数据   | 校验和 |
| (3字节) | (1字节)  | (1字节) | (1字节) | (1字节)    | (变长) | (2字节) |
+--------+---------+--------+---------+------------+--------+--------+
```

其中：

- 包头: 固定为 "DNY" (0x44, 0x4E, 0x59)
- 数据长度: 从物理 ID 到数据的长度（不包括校验和）
- 物理 ID: 设备物理 ID
- 消息 ID: 消息序号
- 命令: 表示数据包的类型和用途
- 数据: 与命令对应的数据内容
- 校验和: CRC16 检验和，用于校验数据完整性

## 6. 使用与开发指南

### 6.1 工具包使用

```go
import "github.com/bujia-iot/iot-zinx/pkg"

// 初始化pkg包依赖关系
pkg.InitPackages()

// 使用协议相关功能
packet := pkg.Protocol.NewDNYDataPackFactory().NewDataPack(true)
result := pkg.Protocol.ParseDNYProtocol(data)
pkg.Protocol.SendDNYResponse(conn, physicalId, messageId, command, data)

// 使用网络相关功能
hooks := pkg.Network.NewConnectionHooks(60*time.Second, 60*time.Second, 120*time.Second)
cmdMgr := pkg.Network.GetCommandManager()

// 使用监控相关功能
monitor := pkg.Monitor.GetGlobalMonitor()
monitor.BindDeviceIdToConnection(deviceId, conn)
monitor.UpdateLastHeartbeatTime(conn)
```

### 6.2 处理器开发

开发新的命令处理器的基本步骤：

1. 在`internal/infrastructure/zinx_server/handlers`目录下创建新的处理器文件
2. 实现`ziface.IRouter`接口
3. 注册处理器到路由系统

```go
type NewCommandHandler struct {
    znet.BaseRouter
}

func (h *NewCommandHandler) Handle(request ziface.IRequest) {
    // 处理逻辑
}

// 注册处理器
func init() {
    server := znet.NewServer()
    server.AddRouter(0xXX, &NewCommandHandler{})
}
```

### 6.3 迁移指南

如果代码仍在使用原`zinx_server`包，请按照以下步骤迁移：

1. 引入 pkg 包并初始化：

```go
import "github.com/bujia-iot/iot-zinx/pkg"

// 初始化包依赖
pkg.InitPackages()
```

2. 替换函数调用：

| 原 zinx_server 函数                    | pkg 包函数                                                |
| -------------------------------------- | --------------------------------------------------------- |
| `zinx_server.SendDNYResponse`          | `pkg.Protocol.SendDNYResponse`                            |
| `zinx_server.ParseDNYProtocol`         | `pkg.Protocol.ParseDNYProtocol`                           |
| `zinx_server.GetCommandManager`        | `pkg.Network.GetCommandManager`                           |
| `zinx_server.GetGlobalMonitor`         | `pkg.Monitor.GetGlobalMonitor`                            |
| `zinx_server.UpdateLastHeartbeatTime`  | `pkg.Monitor.GetGlobalMonitor().UpdateLastHeartbeatTime`  |
| `zinx_server.BindDeviceIdToConnection` | `pkg.Monitor.GetGlobalMonitor().BindDeviceIdToConnection` |

## 7. 日志系统

本项目使用了改进的日志系统，基于`logrus`和`lumberjack`，提供了统一的日志管理、自动轮转、结构化日志和 Zinx 框架集成等功能。

### 7.1 日志特性

- **统一日志管理**: 基于 logrus 的强大日志功能，支持多种日志级别
- **自动日志轮转**: 基于 lumberjack 实现自动日志轮转，避免日志文件过大
- **多路输出**: 同时支持控制台和文件输出，便于开发和生产环境使用
- **结构化日志**: 支持结构化字段，便于日志分析和监控
- **Zinx 框架集成**: 通过适配器模式统一 Zinx 框架日志

### 7.2 日志配置

```yaml
# 日志配置
logger:
  level: "debug" # 日志级别：trace, debug, info, warn, error, fatal, panic
  format: "json" # 输出格式：json, text
  filePath: "./logs/gateway.log" # 日志文件路径
  maxSizeMB: 100 # 最大文件大小（MB）
  maxBackups: 10 # 最大备份文件数量
  maxAgeDays: 30 # 最大保留天数
  logHexDump: true # 是否记录十六进制数据
  enableConsole: true # 是否同时输出到控制台
  enableStructured: true # 是否启用结构化日志
```

## 8. 持续改进计划

### 8.1 后续工作

1. **代码清理**:

   - 移除`internal/infrastructure/zinx_server`目录中的原始代码
   - 移除兼容层文件

2. **迁移 handlers**:

   - 更新`handlers`目录中的所有处理器，直接使用`pkg`包

3. **测试覆盖**:

   - 为`pkg`目录下的所有关键功能添加单元测试
   - 确保测试覆盖率达到 70%以上

4. **文档更新**:

   - 为每个模块添加详细的 API 文档

5. **性能优化**:
   - 分析新架构下的性能瓶颈
   - 优化关键路径上的代码

### 8.2 完成状态

- [x] 创建 pkg 目录结构
- [x] 定义模块接口
- [x] 迁移核心功能
- [x] 创建统一导出接口
- [x] 初始化依赖关系
- [x] 更新使用示例
- [x] 创建兼容层
- [x] 完善文档说明
- [x] 删除重复代码
- [x] 统一接口使用
- [ ] 移除原 zinx_server 目录
- [ ] 更新所有 handler 代码
- [ ] 移除兼容层

## 9. 总结

IoT-Zinx 项目通过近期的重构和架构优化，已经建立了清晰的模块化结构，消除了代码重复，实现了统一的接口规范。项目架构现在具有更好的可维护性、可测试性和可扩展性。系统成功实现了充电设备网关的核心功能，包括设备连接管理、多种心跳管理、刷卡消费、充电控制等。

下一步的工作将集中在移除遗留代码、完善测试覆盖和进一步优化性能上，以确保系统的稳定性和可靠性。同时，项目也将持续改进文档和示例，使其更易于理解和使用。
