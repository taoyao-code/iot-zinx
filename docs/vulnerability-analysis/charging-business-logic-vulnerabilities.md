# IOT-Zinx å……ç”µæ¡©ä¸šåŠ¡é€»è¾‘æ¼æ´æ·±åº¦åˆ†æ

> **ç›¸å…³æ–‡æ¡£**: ç³»ç»Ÿæ•´ä½“æ¶æ„å’ŒæŠ€æœ¯ç‰¹æ€§è¯·å‚è€ƒ [`iot-zinx-comprehensive-analysis.md`](../architecture/iot-zinx-comprehensive-analysis.md)

## 1. æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£ä¸“é—¨åˆ†æIOT-Zinxç³»ç»Ÿä¸­å……ç”µæ¡©ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘æ¼æ´ã€‚åŸºäºç³»ç»Ÿçš„å…­è¾¹å½¢æ¶æ„è®¾è®¡ï¼Œé‡ç‚¹å…³æ³¨å……ç”µæ§åˆ¶ã€è®¢å•çŠ¶æ€ç®¡ç†ã€åŠŸç‡æ§åˆ¶ç­‰æ ¸å¿ƒå……ç”µä¸šåŠ¡åŠŸèƒ½ä¸­å­˜åœ¨çš„å®‰å…¨éšæ‚£å’Œä¸šåŠ¡é€»è¾‘ç¼ºé™·ï¼Œè¿™äº›é—®é¢˜å¯èƒ½å¯¼è‡´è®¢å•æ··ä¹±ã€è®¡è´¹é”™è¯¯ã€è®¾å¤‡æŸåç­‰ä¸¥é‡åæœã€‚

### 1.1 æ¼æ´ç»Ÿè®¡
- **ä¸¥é‡æ¼æ´**: 2ä¸ª (è®¢å•çŠ¶æ€ç®¡ç†ã€å……ç”µçŠ¶æ€æœºç¼ºå¤±)
- **é«˜é£é™©æ¼æ´**: 2ä¸ª (å¹‚ç­‰æ€§é—®é¢˜ã€åŠŸç‡æ§åˆ¶å®‰å…¨)
- **ä¸­ç­‰é£é™©æ¼æ´**: 2ä¸ª (å¿ƒè·³å»é‡ã€é€šçŸ¥å¯é æ€§)
- **ä½é£é™©æ¼æ´**: 2ä¸ª (å‚æ•°éªŒè¯ã€æ—¥å¿—æ³„éœ²)

## 2. å……ç”µä¸šåŠ¡åŠŸèƒ½æ¶æ„åˆ†æ

### 2.1 æ ¸å¿ƒç»„ä»¶å…³ç³»å›¾

```mermaid
graph TB
    subgraph "HTTPæ¥å…¥å±‚"
        API[å……ç”µAPIæ¥å£]
    end
    
    subgraph "ä¸šåŠ¡é€»è¾‘å±‚"
        DG[DeviceGateway]
        OC[OrderContext]
        PC[PowerController]
    end
    
    subgraph "åè®®å¤„ç†å±‚"
        CCH[ChargeControlHandler]
        PHH[PowerHeartbeatHandler]
        SH[SettlementHandler]
    end
    
    subgraph "è®¾å¤‡è¿æ¥å±‚"
        TCM[TCPManager]
        DEV[å……ç”µè®¾å¤‡]
    end
    
    subgraph "äº‹ä»¶æ¨é€å±‚"
        NS[NotificationService]
        TP[ç¬¬ä¸‰æ–¹ç³»ç»Ÿ]
    end
    
    API --> DG
    DG --> OC
    DG --> PC
    DG --> CCH
    CCH --> TCM
    PHH --> PC
    PHH --> NS
    SH --> NS
    TCM <--> DEV
    NS --> TP
```

### 2.2 æ•°æ®æµåˆ†æ

```mermaid
sequenceDiagram
    participant Client as ç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯
    participant API as HTTP API
    participant DG as DeviceGateway
    participant OC as OrderContext
    participant TCM as TCPManager
    participant Device as å……ç”µè®¾å¤‡
    participant NS as NotificationService
    participant TP as ç¬¬ä¸‰æ–¹ç«¯ç‚¹

    Client->>+API: POST /charging/start
    API->>+DG: SendChargingCommand
    
    Note over DG,OC: ğŸš¨æ¼æ´ï¼šç¼ºå°‘çŠ¶æ€æ£€æŸ¥
    DG->>+TCM: SendCommand(0x82)
    TCM->>+Device: 0x82å……ç”µæ§åˆ¶å‘½ä»¤
    Device-->>-TCM: 0x82å“åº”çŠ¶æ€
    TCM-->>-DG: å‘½ä»¤æ‰§è¡Œç»“æœ
    
    alt å……ç”µå¯åŠ¨æˆåŠŸ
        Note over DG,OC: ğŸš¨æ¼æ´ï¼šè®¢å•ä¸Šä¸‹æ–‡æ³„éœ²é£é™©
        DG->>+OC: ä¿å­˜è®¢å•ä¸Šä¸‹æ–‡
        DG->>+NS: SendChargingStartNotification
        NS->>+TP: HTTP POST å……ç”µå¼€å§‹äº‹ä»¶
        TP-->>-NS: å“åº”
    end
    
    DG-->>-API: å……ç”µæ§åˆ¶ç»“æœ
    API-->>-Client: APIå“åº”
    
    loop å……ç”µè¿‡ç¨‹ä¸­
        Device->>+TCM: 0x06åŠŸç‡å¿ƒè·³åŒ…
        TCM->>+DG: å¤„ç†å¿ƒè·³æ•°æ®
        
        Note over DG: ğŸš¨æ¼æ´ï¼šåŠŸç‡æ§åˆ¶å®‰å…¨é—®é¢˜
        DG->>+NS: SendPowerHeartbeat
        NS->>+TP: HTTP POST åŠŸç‡æ•°æ®
        TP-->>-NS: å“åº”
    end
    
    Device->>+TCM: 0x03ç»“ç®—æ•°æ®
    TCM->>+DG: å¤„ç†ç»“ç®—
    Note over OC: ğŸš¨æ¼æ´ï¼šè®¢å•ä¸Šä¸‹æ–‡æœªæ¸…ç†
    DG->>+NS: SendChargingEndNotification
    NS->>+TP: HTTP POST å……ç”µç»“æŸäº‹ä»¶
    TP-->>-NS: å“åº”
```

## 3. ä¸¥é‡æ¼æ´è¯¦ç»†åˆ†æ

### 3.0 åŠŸèƒ½æ‹†è§£ä¸æµç¨‹æ€»è§ˆï¼ˆæ–°å¢ï¼‰

- å¼€å§‹/åœæ­¢å……ç”µï¼ˆHTTP â†’ ç½‘å…³ â†’ 0x82 æŒ‡ä»¤ï¼‰ï¼š
  - HTTP å±‚ï¼šinternal/adapter/http/charging_handlers.go::HandleStartCharging/HandleStopCharging
  - ç½‘å…³å±‚ï¼špkg/gateway/charging.go::SendChargingCommandWithParams/SendStopChargingCommand
  - è®¾å¤‡åº”ç­”ï¼šinternal/infrastructure/zinx_server/handlers/charge_control_handler.go
- å……ç”µè¿‡ç¨‹å¿ƒè·³ï¼š0x06ï¼ˆåŠŸç‡/èƒ½é‡/çŠ¶æ€ï¼‰
  - å¤„ç†ï¼šinternal/infrastructure/zinx_server/handlers/power_heartbeat_handler.goã€port_power_heartbeat_handler.go
- ç»“ç®—ï¼š0x03ï¼ˆæˆ–0x23åˆ†æ—¶ç»“ç®—ï¼‰
  - å¤„ç†ï¼šinternal/infrastructure/zinx_server/handlers/settlement_handler.goã€time_billing_settlement_handler.go
- é€šçŸ¥ï¼špkg/notification/*ï¼Œç¬¬ä¸‰æ–¹äº‹ä»¶æ¨é€
- åè®®è§„èŒƒï¼šdocs/åè®®/AP3000-è®¾å¤‡ä¸æœåŠ¡å™¨é€šä¿¡åè®®.mdï¼›æ˜ å°„ï¼šdocs/architecture/ap3000-mapping.md

### 3.1 è®¢å•çŠ¶æ€ç®¡ç†æ¼æ´ (CVE-Critical-001)

#### 3.1.1 æ¼æ´æè¿°
**æ–‡ä»¶ä½ç½®**: `pkg/gateway/charging.go:102-108`

**é—®é¢˜ä»£ç **:
```go
// åªåœ¨æˆåŠŸå¼€å§‹å……ç”µæ—¶ä¿å­˜è®¢å•ä¸Šä¸‹æ–‡
if action == 0x01 && orderNo != "" {
    key := g.makeOrderCtxKey(deviceID, int(port-1))
    g.orderCtxMu.Lock()
    g.orderCtx[key] = OrderContext{
        OrderNo: orderNo,
        Mode: mode,
        Value: actualValue,
        Balance: balance,
    }
    g.orderCtxMu.Unlock()
}
```

#### 3.1.2 æ¼æ´åˆ†æ
1. **å†…å­˜æ³„éœ²**: è®¢å•ä¸Šä¸‹æ–‡åªåœ¨å……ç”µå¼€å§‹æ—¶ä¿å­˜ï¼Œä½†ä»æœªä¸»åŠ¨æ¸…ç†
2. **è®¢å•é‡å¤**: åŒä¸€ç«¯å£å¯ä»¥é‡å¤å¯åŠ¨å……ç”µï¼Œå¯¼è‡´è®¢å•è¦†ç›–
3. **çŠ¶æ€ä¸ä¸€è‡´**: è®¾å¤‡å¼‚å¸¸æ–­ç”µæ—¶è®¢å•ä¸Šä¸‹æ–‡ä»ç„¶å­˜åœ¨
4. **å¹¶å‘å†²çª**: å¤šä¸ªè¯·æ±‚å¯èƒ½åŒæ—¶æ“ä½œåŒä¸€ç«¯å£çš„è®¢å•ä¸Šä¸‹æ–‡

#### 3.1.3 å½±å“è¯„ä¼°
- **ä¸šåŠ¡å½±å“**: å¯èƒ½å¯¼è‡´é‡å¤è®¡è´¹ã€è®¢å•çŠ¶æ€æ··ä¹±
- **æŠ€æœ¯å½±å“**: å†…å­˜æ³„éœ²å¯¼è‡´ç³»ç»Ÿæ€§èƒ½ä¸‹é™
- **å®‰å…¨å½±å“**: æ•æ„Ÿè®¢å•ä¿¡æ¯é•¿æœŸé©»ç•™å†…å­˜

#### 3.1.4 æ”»å‡»åœºæ™¯
```bash
# æ”»å‡»è€…å¯ä»¥é€šè¿‡é‡å¤è°ƒç”¨å……ç”µæ¥å£å¯¼è‡´è®¢å•æ··ä¹±
curl -X POST "http://gateway/api/v1/charging/start" \
  -H "Content-Type: application/json" \
  -d '{"device_id":"DEV001","port":1,"order_no":"ORDER001"}'

# ç«‹å³å‘é€åœæ­¢å‘½ä»¤
curl -X POST "http://gateway/api/v1/charging/stop" \
  -H "Content-Type: application/json" \
  -d '{"device_id":"DEV001","port":1,"order_no":"ORDER002"}'

# è®¢å•ä¸Šä¸‹æ–‡æ··ä¹±ï¼Œå¯èƒ½å¯¼è‡´è®¡è´¹é”™è¯¯
```

#### 3.1.5 ä¿®å¤å»ºè®®
```go
// å»ºè®®çš„ä¿®å¤æ–¹æ¡ˆ
type OrderManager struct {
    orders map[string]*OrderState
    mutex  sync.RWMutex
}

type OrderState struct {
    OrderNo    string
    Status     OrderStatus
    DeviceID   string
    Port       int
    StartTime  time.Time
    EndTime    *time.Time
    LastUpdate time.Time
}

type OrderStatus int

const (
    OrderStatusPending OrderStatus = iota
    OrderStatusCharging
    OrderStatusCompleted
    OrderStatusCancelled
    OrderStatusFailed
)

func (om *OrderManager) CreateOrder(deviceID string, port int, orderNo string) error {
    om.mutex.Lock()
    defer om.mutex.Unlock()
    
    key := fmt.Sprintf("%s:%d", deviceID, port)
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¿›è¡Œä¸­çš„è®¢å•
    if existing, exists := om.orders[key]; exists {
        if existing.Status == OrderStatusCharging || existing.Status == OrderStatusPending {
            return fmt.Errorf("ç«¯å£ %s:%d å·²æœ‰è¿›è¡Œä¸­çš„è®¢å•: %s", deviceID, port, existing.OrderNo)
        }
    }
    
    om.orders[key] = &OrderState{
        OrderNo:    orderNo,
        Status:     OrderStatusPending,
        DeviceID:   deviceID,
        Port:       port,
        StartTime:  time.Now(),
        LastUpdate: time.Now(),
    }
    
    return nil
}

func (om *OrderManager) UpdateOrderStatus(deviceID string, port int, status OrderStatus) error {
    om.mutex.Lock()
    defer om.mutex.Unlock()
    
    key := fmt.Sprintf("%s:%d", deviceID, port)
    order, exists := om.orders[key]
    if !exists {
        return fmt.Errorf("è®¢å•ä¸å­˜åœ¨: %s", key)
    }
    
    order.Status = status
    order.LastUpdate = time.Now()
    
    if status == OrderStatusCompleted || status == OrderStatusCancelled || status == OrderStatusFailed {
        endTime := time.Now()
        order.EndTime = &endTime
        
        // å¼‚æ­¥æ¸…ç†è¿‡æœŸè®¢å•
        go om.cleanupExpiredOrders()
    }
    
return nil
}
```

#### 3.1.6 ä¿®å¤å®ç°è¦ç‚¹ä¸æ¸…ç†ç­–ç•¥ï¼ˆæ–°å¢ï¼‰
- è®¢å•ä¸Šä¸‹æ–‡æ¸…ç†è§¦å‘ç‚¹ï¼š
  - æ”¶åˆ° 0x03/0x23 ç»“ç®—åŒ…å¹¶æ ¡éªŒé€šè¿‡åï¼›
  - æ”¶åˆ°â€œå……ç”µç»“æŸâ€äº‹ä»¶ï¼ˆå«ç”± 0x44/0x43 ç­‰å¼•å‘çš„ç»“æŸï¼‰åï¼›
  - å‘ç”Ÿæ˜ç¡®å¤±è´¥ï¼ˆè®¾å¤‡è¿”å›é”™è¯¯çŠ¶æ€ä¸”ç¡®è®¤æœªæ‰§è¡Œï¼‰åã€‚
- æ¸…ç†èŒƒå›´ï¼šdeviceID+port é”®ä¸‹çš„ OrderContextï¼ŒåŒ…æ‹¬ orderNoã€modeã€valueã€balance ç­‰ã€‚
- å¹¶å‘ä¸å¹‚ç­‰ï¼šæ¸…ç†æ“ä½œéœ€å¯é‡å…¥ï¼Œä¸”ä¸å½±å“å…¶ä»–ç«¯å£è®¢å•ï¼›å»ºè®®ä½¿ç”¨ç»†ç²’åº¦äº’æ–¥æˆ–åŸºäº CAS çš„ map æ›´æ–°ã€‚
- è§‚æµ‹æ€§ï¼šåœ¨æ¸…ç†æ—¶è¾“å‡ºç»“æ„åŒ–æ—¥å¿—ï¼ŒåŒ…å« deviceIDã€portã€orderNoã€è§¦å‘åŸå› ã€‚

---

### 3.2 å……ç”µçŠ¶æ€æœºç¼ºå¤±æ¼æ´ (CVE-Critical-002)

#### 3.2.1 æ¼æ´æè¿°
**æ–‡ä»¶ä½ç½®**: `internal/infrastructure/zinx_server/handlers/power_heartbeat_handler.go`

**é—®é¢˜åˆ†æ**:
ç³»ç»Ÿç¼ºä¹å®Œæ•´çš„å……ç”µçŠ¶æ€æœºï¼Œåªé€šè¿‡å¿ƒè·³åŒ…ä¸­çš„ç«¯å£çŠ¶æ€æ¥åˆ¤æ–­å……ç”µçŠ¶æ€ï¼Œæ— æ³•å¤„ç†å¤æ‚çš„çŠ¶æ€è½¬æ¢å’Œå¼‚å¸¸æƒ…å†µã€‚

#### 3.2.2 æ¼æ´åˆ†æ
1. **çŠ¶æ€ä¸ä¸€è‡´**: å¿ƒè·³åŒ…ä¸¢å¤±æˆ–å»¶è¿Ÿæ—¶çŠ¶æ€åˆ¤æ–­é”™è¯¯
2. **å¼‚å¸¸çŠ¶æ€å¤„ç†**: æ— æ³•å¤„ç†è®¾å¤‡å¼‚å¸¸çŠ¶æ€ï¼ˆå¦‚è¿‡æ¸©ã€çŸ­è·¯ï¼‰
3. **çŠ¶æ€è½¬æ¢éªŒè¯**: ç¼ºä¹çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§éªŒè¯
4. **å¹¶å‘çŠ¶æ€å†²çª**: å¤šä¸ªç«¯å£çŠ¶æ€å¯èƒ½ç›¸äº’å½±å“

#### 3.2.3 å½“å‰çŠ¶æ€åˆ¤æ–­é€»è¾‘
```go
// å½“å‰çš„ç®€å•çŠ¶æ€åˆ¤æ–­
portStatus := rawData[portIndex+2]
isCharging := portStatus == 0x01 || portStatus == 0x05 // å……ç”µä¸­æˆ–æµ®å……

// é—®é¢˜ï¼šç¼ºä¹çŠ¶æ€è½¬æ¢éªŒè¯å’Œå¼‚å¸¸å¤„ç†
```

#### 3.2.4 ä¿®å¤å»ºè®®
```go
// å®Œæ•´çš„å……ç”µçŠ¶æ€æœºå®ç°
type ChargingState int

const (
    StateIdle ChargingState = iota
    StatePlugged
    StateCharging
    StateFloatCharging
    StateCompleted
    StateFault
    StateEmergencyStop
)

type ChargingStateMachine struct {
    currentState ChargingState
    deviceID     string
    port         int
    transitions  map[ChargingState][]ChargingState
    stateChanges chan StateChange
    mutex        sync.RWMutex
}

type StateChange struct {
    DeviceID  string
    Port      int
    FromState ChargingState
    ToState   ChargingState
    Timestamp time.Time
    Reason    string
    Data      map[string]interface{}
}

func NewChargingStateMachine(deviceID string, port int) *ChargingStateMachine {
    return &ChargingStateMachine{
        currentState: StateIdle,
        deviceID:     deviceID,
        port:         port,
        transitions: map[ChargingState][]ChargingState{
            StateIdle:          {StatePlugged, StateFault},
            StatePlugged:       {StateCharging, StateIdle, StateFault},
            StateCharging:      {StateFloatCharging, StateCompleted, StateFault, StateEmergencyStop},
            StateFloatCharging: {StateCompleted, StateFault, StateEmergencyStop},
            StateCompleted:     {StateIdle, StateFault},
            StateFault:         {StateIdle}, // æ•…éšœä¿®å¤åå›åˆ°ç©ºé—²
            StateEmergencyStop: {StateIdle, StateFault},
        },
        stateChanges: make(chan StateChange, 100),
    }
}

func (csm *ChargingStateMachine) TransitionTo(newState ChargingState, reason string, data map[string]interface{}) error {
    csm.mutex.Lock()
    defer csm.mutex.Unlock()
    
    // éªŒè¯çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§
    allowedTransitions, exists := csm.transitions[csm.currentState]
    if !exists {
        return fmt.Errorf("æœªå®šä¹‰çŠ¶æ€ %v çš„è½¬æ¢è§„åˆ™", csm.currentState)
    }
    
    allowed := false
    for _, allowedState := range allowedTransitions {
        if allowedState == newState {
            allowed = true
            break
        }
    }
    
    if !allowed {
        return fmt.Errorf("ä¸å…è®¸ä» %v è½¬æ¢åˆ° %v", csm.currentState, newState)
    }
    
    // è®°å½•çŠ¶æ€å˜æ›´
    change := StateChange{
        DeviceID:  csm.deviceID,
        Port:      csm.port,
        FromState: csm.currentState,
        ToState:   newState,
        Timestamp: time.Now(),
        Reason:    reason,
        Data:      data,
    }
    
    // æ›´æ–°çŠ¶æ€
    oldState := csm.currentState
    csm.currentState = newState
    
    // å¼‚æ­¥å‘é€çŠ¶æ€å˜æ›´äº‹ä»¶
    go func() {
        select {
        case csm.stateChanges <- change:
        default:
            // é˜Ÿåˆ—æ»¡æ—¶è®°å½•è­¦å‘Š
            logger.Warn("çŠ¶æ€å˜æ›´é˜Ÿåˆ—å·²æ»¡ï¼Œä¸¢å¼ƒäº‹ä»¶", map[string]interface{}{
                "device_id": csm.deviceID,
                "port":      csm.port,
                "change":    change,
            })
        }
    }()
    
    return nil
}
```

### 3.3 ç«¯å£å·æ˜ å°„ä¸€è‡´æ€§æ¼æ´ (CVE-Critical-003)

#### 3.3.1 æ¼æ´æè¿°
æ–‡ä»¶ä½ç½®å¯¹æ¯”ï¼š
- ç®€ç‰ˆå‘½ä»¤ï¼špkg/gateway/charging.go::SendChargingCommand â†’ commandData := []byte{port, action}
- å®Œæ•´å‘½ä»¤ï¼špkg/gateway/charging.go::SendChargingCommandWithParams â†’ commandData[5] = port - 1

ç®€ç‰ˆå‘½ä»¤æœªè¿›è¡Œ 1-basedâ†’0-based çš„ç«¯å£è½¬æ¢ï¼Œå®Œæ•´å‘½ä»¤è¿›è¡Œäº† port-1ã€‚è‹¥å¤–éƒ¨å‡ä»¥1-basedç«¯å£ä¼ å…¥ï¼Œä¸¤æ¡è·¯å¾„å‘å¾€è®¾å¤‡çš„ç«¯å£å¯èƒ½ä¸ä¸€è‡´ï¼Œå¼•å‘é”™è¯¯å£é€šæ–­ç”µçš„ä¸¥é‡åæœã€‚

#### 3.3.2 å½±å“è¯„ä¼°
- ä¸¥é‡ï¼šå¯èƒ½å¯¼è‡´éç›®æ ‡ç«¯å£ä¸Šç”µ/æ–­ç”µï¼Œå¸¦æ¥å®‰å…¨ä¸ä¸šåŠ¡é£é™©ã€‚
- å¯é‡ç°ï¼šé€šè¿‡ Web æ§åˆ¶å°æˆ– API åˆ†åˆ«èµ°ç®€ç‰ˆä¸å®Œæ•´ç‰ˆå‘½ä»¤ï¼Œè§‚å¯Ÿè®¾å¤‡ç«¯å£è¡Œä¸ºå·®å¼‚ã€‚

#### 3.3.3 å¤ç°åœºæ™¯
- å‰ç½®ï¼šè®¾å¤‡æœ‰è‡³å°‘2ä¸ªç«¯å£ï¼›å¤–éƒ¨ä»¥ port=1 å‘èµ·ã€‚
- è·¯å¾„Aï¼ˆç®€ç‰ˆï¼‰ï¼šSendChargingCommand(deviceID, 1, 0x01) â†’ è®¾å¤‡æ”¶åˆ°ç«¯å£=0x01ï¼ˆåè®®è§†ä¸ºç¬¬2è·¯ï¼‰ã€‚
- è·¯å¾„Bï¼ˆå®Œæ•´ï¼‰ï¼šSendChargingCommandWithParams(deviceID, 1, ...) â†’ è®¾å¤‡æ”¶åˆ°ç«¯å£=0x00ï¼ˆåè®®è§†ä¸ºç¬¬1è·¯ï¼‰ã€‚

#### 3.3.4 ä¿®å¤å»ºè®®
- ç»Ÿä¸€ç«¯å£è½¬æ¢ç­–ç•¥ï¼š
  - ç½‘å…³å±‚å¯¹æ‰€æœ‰â€œå‘é€åˆ°è®¾å¤‡çš„ç«¯å£å­—æ®µâ€ä¸€å¾‹é‡‡ç”¨åè®®0-basedï¼ˆport-1ï¼‰ï¼Œå¯¹å¤–æš´éœ²/æ—¥å¿—/é€šçŸ¥ä¸€å¾‹1-basedã€‚
- ä»£ç è°ƒæ•´å»ºè®®ï¼š
  - SendChargingCommand åœ¨æ„é€  commandData æ—¶å°†ç¬¬ä¸€ä¸ªå­—èŠ‚æ”¹ä¸º port-1ï¼›åŒæ—¶åœ¨æ—¥å¿—ä¸­ç»§ç»­ä½¿ç”¨ displayPort=portã€‚
- å›å½’æµ‹è¯•è¦ç‚¹ï¼š
  - è¦†ç›–ç«¯å£[1..N]åŒè·¯å¾„ä¸€è‡´æ€§ï¼›
  - è®¾å¤‡åº”ç­”ç«¯å£æ˜ å°„æ­£ç¡®ï¼ˆ0-basedâ†’1-basedæ˜¾ç¤ºï¼‰ï¼›
  - 0xFFï¼ˆæ™ºèƒ½é€‰æ‹©ç«¯å£ï¼‰ä¿æŒé€ä¼ ä¸å˜ã€‚

---

## 4. é«˜é£é™©æ¼æ´è¯¦ç»†åˆ†æ

### 4.1 å……ç”µå‘½ä»¤å¹‚ç­‰æ€§é—®é¢˜ (CVE-High-001)

#### 4.1.1 æ¼æ´æè¿°
**æ–‡ä»¶ä½ç½®**: `internal/adapter/http/charging_handlers.go:45-51`

**é—®é¢˜ä»£ç **:
```go
// ç›´æ¥å‘é€å……ç”µå‘½ä»¤ï¼Œæ²¡æœ‰çŠ¶æ€æ£€æŸ¥
if err := h.deviceGateway.SendChargingCommandWithParams(standardDeviceID, req.Port, 0x01, req.OrderNo, req.Mode, req.Value, req.Balance); err != nil {
    c.JSON(http.StatusInternalServerError, APIResponse{Code: 500, Message: "å……ç”µå¯åŠ¨å¤±è´¥", Data: gin.H{"error": err.Error()}})
    return
}
```

#### 4.1.2 æ¼æ´å½±å“
1. **é‡å¤å……ç”µ**: åŒä¸€ç«¯å£å¯èƒ½è¢«é‡å¤å¯åŠ¨
2. **è®¢å•å†²çª**: ä¸åŒè®¢å•æ“ä½œåŒä¸€ç«¯å£
3. **è®¡è´¹æ··ä¹±**: é‡å¤çš„å……ç”µå‘½ä»¤å¯èƒ½å¯¼è‡´è®¡è´¹é”™è¯¯

#### 4.1.3 ä¿®å¤å»ºè®®
```go
func (h *ChargingHandlers) HandleStartCharging(c *gin.Context) {
    var req ChargingStartRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, APIResponse{Code: 400, Message: "å‚æ•°é”™è¯¯", Data: gin.H{"error": err.Error()}})
        return
    }
    
    standardDeviceID := utils.ProcessDeviceID(req.DeviceID)
    
    // å¹‚ç­‰æ€§æ£€æŸ¥
    if err := h.checkChargingIdempotency(standardDeviceID, req.Port, req.OrderNo); err != nil {
        c.JSON(http.StatusConflict, APIResponse{Code: 409, Message: "å……ç”µçŠ¶æ€å†²çª", Data: gin.H{"error": err.Error()}})
        return
    }
    
    // è®¾å¤‡çŠ¶æ€æ£€æŸ¥
    if !h.isDeviceOnline(standardDeviceID) {
        c.JSON(http.StatusServiceUnavailable, APIResponse{Code: 503, Message: "è®¾å¤‡ç¦»çº¿", Data: nil})
        return
    }
    
    // ç«¯å£çŠ¶æ€æ£€æŸ¥
    portStatus, err := h.getPortStatus(standardDeviceID, req.Port)
    if err != nil {
        c.JSON(http.StatusInternalServerError, APIResponse{Code: 500, Message: "è·å–ç«¯å£çŠ¶æ€å¤±è´¥", Data: gin.H{"error": err.Error()}})
        return
    }
    
    if !canStartCharging(portStatus) {
        c.JSON(http.StatusConflict, APIResponse{Code: 409, Message: "ç«¯å£çŠ¶æ€ä¸å…è®¸å……ç”µ", Data: gin.H{"status": portStatus}})
        return
    }
    
    // ä½¿ç”¨åˆ†å¸ƒå¼é”ç¡®ä¿åŸå­æ“ä½œ
    lockKey := fmt.Sprintf("charging_lock:%s:%d", standardDeviceID, req.Port)
    if !h.acquireLock(lockKey, 30*time.Second) {
        c.JSON(http.StatusTooManyRequests, APIResponse{Code: 429, Message: "è®¾å¤‡æ­£åœ¨å¤„ç†å…¶ä»–å……ç”µè¯·æ±‚", Data: nil})
        return
    }
    defer h.releaseLock(lockKey)
    
    // å‘é€å……ç”µå‘½ä»¤
    if err := h.deviceGateway.SendChargingCommandWithParams(standardDeviceID, req.Port, 0x01, req.OrderNo, req.Mode, req.Value, req.Balance); err != nil {
        c.JSON(http.StatusInternalServerError, APIResponse{Code: 500, Message: "å……ç”µå¯åŠ¨å¤±è´¥", Data: gin.H{"error": err.Error()}})
        return
    }
    
    c.JSON(http.StatusOK, APIResponse{Code: 0, Message: "å……ç”µå¯åŠ¨æˆåŠŸ", Data: gin.H{"device_id": standardDeviceID, "port": req.Port, "order_no": req.OrderNo}})
}

func (h *ChargingHandlers) checkChargingIdempotency(deviceID string, port int, orderNo string) error {
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒè®¢å•çš„å……ç”µè¯·æ±‚
    existing := h.orderManager.GetOrder(deviceID, port)
    if existing != nil {
        if existing.OrderNo == orderNo {
            // ç›¸åŒè®¢å•ï¼Œæ£€æŸ¥çŠ¶æ€
            if existing.Status == OrderStatusCharging {
                return nil // å¹‚ç­‰ï¼Œè¿”å›æˆåŠŸ
            }
        } else {
            // ä¸åŒè®¢å•ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å†²çª
            if existing.Status == OrderStatusCharging || existing.Status == OrderStatusPending {
                return fmt.Errorf("ç«¯å£å·²æœ‰è¿›è¡Œä¸­çš„è®¢å•: %s", existing.OrderNo)
            }
        }
    }
    return nil
}
```

### 4.2 åŠŸç‡æ§åˆ¶å®‰å…¨æ¼æ´ (CVE-High-002)

#### 4.2.1 æ¼æ´æè¿°
**æ–‡ä»¶ä½ç½®**: `pkg/gateway/dynamic_power_controller.go:89-95`

**é—®é¢˜ä»£ç **:
```go
// æ™ºèƒ½é™åŠŸç‡æ§åˆ¶é€»è¾‘
target := int(math.Max(float64(lastOver)*(1.0-step), float64(minW)))
if abs(target-lastOver) < d.cfg.ChangeThresholdW {
    return // é˜²æŠ–æœºåˆ¶å¯èƒ½å¯¼è‡´åŠŸç‡æ— æ³•åŠæ—¶è°ƒæ•´
}
```

#### 4.2.2 æ¼æ´åˆ†æ
1. **é˜²æŠ–å»¶è¿Ÿ**: é˜²æŠ–æœºåˆ¶å¯èƒ½å¯¼è‡´å±é™©åŠŸç‡æŒç»­æ—¶é—´è¿‡é•¿
2. **æœ€å°åŠŸç‡é™åˆ¶**: æœ€å°åŠŸç‡å¯èƒ½ä¸è¶³ä»¥ä¿æŠ¤è®¾å¤‡
3. **è®¡ç®—ç²¾åº¦**: æµ®ç‚¹æ•°è®¡ç®—å¯èƒ½å¯¼è‡´ç²¾åº¦ä¸¢å¤±
4. **å¼‚å¸¸å¤„ç†**: ç¼ºä¹å¯¹å¼‚å¸¸åŠŸç‡å€¼çš„å¤„ç†

#### 4.2.3 ä¿®å¤å»ºè®®
```go
type SafePowerController struct {
    cfg                *PowerControlConfig
    emergencyThreshold int     // ç´§æ€¥åœæ­¢é˜ˆå€¼
    maxContinuousTime  time.Duration // æœ€å¤§è¿ç»­é«˜åŠŸç‡æ—¶é—´
    powerHistory       *PowerHistory
    mutex              sync.RWMutex
}

type PowerHistory struct {
    records    []PowerRecord
    maxRecords int
}

type PowerRecord struct {
    Timestamp time.Time
    Power     int
    Action    string
    DeviceID  string
    Port      int
}

func (spc *SafePowerController) CalculateSafePower(deviceID string, port int, currentPower, overloadPower int) (int, error) {
    spc.mutex.Lock()
    defer spc.mutex.Unlock()
    
    // ç´§æ€¥å®‰å…¨æ£€æŸ¥
    if currentPower > spc.emergencyThreshold {
        // ç«‹å³ç´§æ€¥åœæ­¢
        spc.recordPowerAction(deviceID, port, 0, "emergency_stop")
        return 0, fmt.Errorf("åŠŸç‡è¶…è¿‡ç´§æ€¥é˜ˆå€¼ %dWï¼Œæ‰§è¡Œç´§æ€¥åœæ­¢", spc.emergencyThreshold)
    }
    
    // æ£€æŸ¥è¿ç»­é«˜åŠŸç‡æ—¶é—´
    if spc.isHighPowerTooLong(deviceID, port, overloadPower) {
        reducedPower := int(float64(overloadPower) * 0.8) // ç«‹å³é™ä½20%
        spc.recordPowerAction(deviceID, port, reducedPower, "continuous_high_power_protection")
        return reducedPower, nil
    }
    
    // æ ‡å‡†åŠŸç‡æ§åˆ¶é€»è¾‘
    step := spc.cfg.StepPercent
    minW := spc.cfg.MinPowerW
    
    // ä½¿ç”¨æ›´å®‰å…¨çš„è®¡ç®—æ–¹å¼
    reductionAmount := int(float64(overloadPower) * step)
    target := overloadPower - reductionAmount
    
    // ç¡®ä¿ä¸ä½äºå®‰å…¨æœ€å°å€¼
    safeMinPower := max(minW, spc.calculateSafeMinPower(deviceID, port))
    target = max(target, safeMinPower)
    
    // è®°å½•åŠŸç‡è°ƒæ•´å†å²
    spc.recordPowerAction(deviceID, port, target, "normal_reduction")
    
    return target, nil
}

func (spc *SafePowerController) isHighPowerTooLong(deviceID string, port int, power int) bool {
    now := time.Now()
    threshold := now.Add(-spc.maxContinuousTime)
    
    continuousHighPowerTime := time.Duration(0)
    for i := len(spc.powerHistory.records) - 1; i >= 0; i-- {
        record := spc.powerHistory.records[i]
        if record.DeviceID != deviceID || record.Port != port {
            continue
        }
        if record.Timestamp.Before(threshold) {
            break
        }
        if record.Power >= power {
            continuousHighPowerTime += time.Minute // å‡è®¾æ¯æ¡è®°å½•é—´éš”1åˆ†é’Ÿ
        } else {
            break // åŠŸç‡ä¸­æ–­
        }
    }
    
    return continuousHighPowerTime > spc.maxContinuousTime
}

func (spc *SafePowerController) calculateSafeMinPower(deviceID string, port int) int {
    // æ ¹æ®è®¾å¤‡ç±»å‹å’Œå†å²æ•°æ®è®¡ç®—å®‰å…¨æœ€å°åŠŸç‡
    deviceType := spc.getDeviceType(deviceID)
    switch deviceType {
    case "AC_CHARGER":
        return 300 // äº¤æµå……ç”µæ¡©æœ€å°300W
    case "DC_CHARGER":
        return 1000 // ç›´æµå……ç”µæ¡©æœ€å°1000W
    default:
        return 200 // é»˜è®¤æœ€å°200W
    }
}
```

### 4.3 åœæ­¢å……ç”µè®¢å•æ ¡éªŒç¼ºå¤± (CVE-High-003)

#### 4.3.1 æ¼æ´æè¿°
- æ–‡ä»¶ä½ç½®ï¼šinternal/adapter/http/charging_handlers.go::HandleStopCharging
- é—®é¢˜ï¼šè°ƒç”¨ SendChargingCommandWithParams(..., action=0x00, orderNo=req.OrderNo) å‰ï¼Œæœªæ ¡éªŒ req.OrderNo æ˜¯å¦ä¸è®¾å¤‡å½“å‰æ­£åœ¨å……ç”µçš„è®¢å•ä¸€è‡´ã€‚
- åè®®çº¦æŸï¼šAP3000 æ˜ç¡®â€œè¿œç¨‹åœæ­¢å……ç”µéœ€è¦ä¸‹å‘å¯¹å½“å‰æ­£åœ¨å……ç”µçš„è®¢å•å·ï¼Œå¦‚æœè®¢å•å·å¯¹ä¸ä¸Šåˆ™æ— æ³•è¿œç¨‹åœæ­¢â€ã€‚

#### 4.3.2 å½±å“è¯„ä¼°
- é«˜é£é™©ï¼šè¿œç¨‹åœå……æ¥å£å¯¹ç”¨æˆ·è¡¨ç°ä¸ºâ€œå·²åœæ­¢â€ï¼Œå®é™…è®¾å¤‡æœªæ‰§è¡Œï¼Œå¯¼è‡´è®¡è´¹ä¸å®‰å…¨é£é™©ã€‚

#### 4.3.3 ä¿®å¤å»ºè®®
- åœ¨ HTTP å±‚/ç½‘å…³å±‚å¢åŠ è®¢å•åŒ¹é…æ ¡éªŒï¼š
  - åŸºäº DeviceGateway ç»´æŠ¤çš„è¿›è¡Œä¸­è®¢å•ï¼ˆdeviceID+portï¼‰æ ¡éªŒ orderNo ä¸€è‡´æ€§ï¼›
  - è‹¥ä¸ä¸€è‡´ï¼šè¿”å› 409 å†²çªå¹¶æç¤ºå½“å‰è®¢å•å·ï¼›
  - è‹¥ä¸ºç©ºï¼šå…è®¸â€œæ— è®¢å•å·â€æ–¹æ¡ˆä»…åœ¨æ˜ç¡®ä¸šåŠ¡å…è®¸ä¸”è®¾å¤‡ç«¯æ”¯æŒæ—¶å¼€æ”¾ï¼Œå¦åˆ™æ‹’ç»ã€‚
- å¯é€‰ï¼šé€šè¿‡æœ€è¿‘ä¸€æ¬¡ 0x06/0x04 å¸§å†…çš„è®¢å•å·ä½œä¸ºå…œåº•åŒ¹é…ã€‚

#### 4.3.4 å›å½’æµ‹è¯•
- è¿›è¡Œä¸­è®¢å•ä¸åœæ­¢å‚æ•°åŒ¹é…/ä¸åŒ¹é…ä¸¤ç±»åœºæ™¯ï¼›
- ä¸åŒè®¾å¤‡å‹å·è¡Œä¸ºå·®å¼‚ï¼ˆè‹¥å­˜åœ¨ï¼‰ï¼Œç¡®ä¿æœ€å°å…¬çº¦æ•°ç­–ç•¥ã€‚

---

## 5. ä¸­ç­‰é£é™©æ¼æ´åˆ†æ

### 5.1 å¿ƒè·³å»é‡æœºåˆ¶é—®é¢˜ (CVE-Medium-001)

#### 5.1.1 é—®é¢˜æè¿°
å›ºå®š5ç§’çš„å»é‡é—´éš”å¯èƒ½å¯¼è‡´é‡è¦çŠ¶æ€å˜åŒ–è¢«å¿½ç•¥ï¼Œç‰¹åˆ«æ˜¯åœ¨åŠŸç‡å¼‚å¸¸æˆ–è®¾å¤‡æ•…éšœæ—¶ã€‚

#### 5.1.2 ä¿®å¤å»ºè®®
```go
type AdaptiveHeartbeatFilter struct {
    lastHeartbeat    map[string]time.Time
    minInterval      map[string]time.Duration
    criticalEvents   map[string]bool
    mutex            sync.RWMutex
}

func (ahf *AdaptiveHeartbeatFilter) ShouldProcess(deviceID string, eventType string, data map[string]interface{}) bool {
    ahf.mutex.Lock()
    defer ahf.mutex.Unlock()
    
    key := fmt.Sprintf("%s:%s", deviceID, eventType)
    now := time.Now()
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå…³é”®äº‹ä»¶
    if ahf.isCriticalEvent(eventType, data) {
        ahf.lastHeartbeat[key] = now
        return true // å…³é”®äº‹ä»¶æ€»æ˜¯å¤„ç†
    }
    
    // è·å–åŠ¨æ€é—´éš”
    interval := ahf.getDynamicInterval(deviceID, eventType, data)
    
    if lastTime, exists := ahf.lastHeartbeat[key]; exists {
        if now.Sub(lastTime) < interval {
            return false // åœ¨å»é‡é—´éš”å†…ï¼Œè·³è¿‡
        }
    }
    
    ahf.lastHeartbeat[key] = now
    return true
}

func (ahf *AdaptiveHeartbeatFilter) isCriticalEvent(eventType string, data map[string]interface{}) bool {
    // å®šä¹‰å…³é”®äº‹ä»¶
    switch eventType {
    case "power_alarm":
        return true
    case "fault_status":
        return true
    case "emergency_stop":
        return true
    case "power_heartbeat":
        // æ£€æŸ¥åŠŸç‡æ˜¯å¦å¼‚å¸¸
        if power, ok := data["power"].(int); ok {
            return power > 15000 || power < 100 // å¼‚å¸¸åŠŸç‡å€¼
        }
    }
    return false
}

func (ahf *AdaptiveHeartbeatFilter) getDynamicInterval(deviceID string, eventType string, data map[string]interface{}) time.Duration {
    // æ ¹æ®äº‹ä»¶ç±»å‹å’Œè®¾å¤‡çŠ¶æ€åŠ¨æ€è°ƒæ•´é—´éš”
    switch eventType {
    case "power_heartbeat":
        if power, ok := data["power"].(int); ok {
            if power > 10000 {
                return 1 * time.Second // é«˜åŠŸç‡æ—¶æ›´é¢‘ç¹
            }
        }
        return 5 * time.Second // æ­£å¸¸åŠŸç‡
    case "status_heartbeat":
        return 10 * time.Second // çŠ¶æ€å¿ƒè·³å¯ä»¥è¾ƒæ…¢
    default:
        return 5 * time.Second // é»˜è®¤é—´éš”
    }
}
```

### 5.2 é€šçŸ¥æœºåˆ¶å¯é æ€§é—®é¢˜ (CVE-Medium-002)

#### 5.2.1 é—®é¢˜æè¿°
å½“å‰é€šçŸ¥ç³»ç»Ÿåœ¨é‡è¯•å¤±è´¥åä¼šæ°¸ä¹…ä¸¢å¼ƒäº‹ä»¶ï¼Œå¯¹äºå…³é”®ä¸šåŠ¡äº‹ä»¶ï¼ˆå¦‚å……ç”µå¼€å§‹/ç»“æŸï¼‰è¿™æ˜¯ä¸å¯æ¥å—çš„ã€‚

#### 5.2.2 ä¿®å¤å»ºè®®
```go
type ReliableNotificationService struct {
    service           *NotificationService
    deadLetterQueue   chan *NotificationEvent
    criticalEvents    map[string]bool
    persistentStorage PersistentStorage
}

type PersistentStorage interface {
    SaveEvent(event *NotificationEvent) error
    LoadEvents() ([]*NotificationEvent, error)
    MarkEventProcessed(eventID string) error
}

func (rns *ReliableNotificationService) SendNotification(event *NotificationEvent) error {
    // æ ‡è®°å…³é”®äº‹ä»¶
    if rns.isCriticalEvent(event.EventType) {
        event.IsCritical = true
        // å…³é”®äº‹ä»¶å…ˆæŒä¹…åŒ–
        if err := rns.persistentStorage.SaveEvent(event); err != nil {
            logger.Error("ä¿å­˜å…³é”®äº‹ä»¶å¤±è´¥", map[string]interface{}{
                "event_id":   event.EventID,
                "event_type": event.EventType,
                "error":      err,
            })
            // å³ä½¿æŒä¹…åŒ–å¤±è´¥ï¼Œä¹Ÿè¦å°è¯•å‘é€
        }
    }
    
    return rns.service.SendNotification(event)
}

func (rns *ReliableNotificationService) handleFailedEvent(event *NotificationEvent) {
    if event.IsCritical {
        // å…³é”®äº‹ä»¶è¿›å…¥æ­»ä¿¡é˜Ÿåˆ—
        select {
        case rns.deadLetterQueue <- event:
            logger.Warn("å…³é”®äº‹ä»¶è¿›å…¥æ­»ä¿¡é˜Ÿåˆ—", map[string]interface{}{
                "event_id":   event.EventID,
                "event_type": event.EventType,
            })
        default:
            // æ­»ä¿¡é˜Ÿåˆ—æ»¡ï¼Œè®°å½•åˆ°æŒä¹…å­˜å‚¨
            if err := rns.persistentStorage.SaveEvent(event); err != nil {
                logger.Error("ä¿å­˜å¤±è´¥äº‹ä»¶åˆ°æŒä¹…å­˜å‚¨å¤±è´¥", map[string]interface{}{
                    "event_id":   event.EventID,
                    "event_type": event.EventType,
                    "error":      err,
                })
            }
        }
    }
}

func (rns *ReliableNotificationService) startDeadLetterProcessor() {
    go func() {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for {
            select {
            case event := <-rns.deadLetterQueue:
                // ä½¿ç”¨æŒ‡æ•°é€€é¿é‡è¯•æ­»ä¿¡äº‹ä»¶
                rns.retryDeadLetterEvent(event)
            case <-ticker.C:
                // å®šæœŸä»æŒä¹…å­˜å‚¨åŠ è½½æœªå¤„ç†äº‹ä»¶
                rns.loadAndRetryPersistentEvents()
            }
        }
    }()
}

func (rns *ReliableNotificationService) isCriticalEvent(eventType string) bool {
    criticalTypes := map[string]bool{
        "charging_start":  true,
        "charging_end":    true,
        "charging_failed": true,
        "settlement":      true,
        "device_offline":  true,
    }
    return criticalTypes[eventType]
}
```

## 6. ä½é£é™©æ¼æ´åˆ†æ

### 6.1 å‚æ•°éªŒè¯ä¸å®Œæ•´ (CVE-Low-001)

#### 6.1.1 é—®é¢˜åˆ†æ
å½“å‰å‚æ•°éªŒè¯è¿‡äºç®€å•ï¼Œå¯èƒ½å¯¼è‡´æ— æ•ˆæ•°æ®è¿›å…¥ç³»ç»Ÿã€‚

#### 6.1.2 ä¿®å¤å»ºè®®
```go
type ChargingRequestValidator struct {
    orderNoPattern *regexp.Regexp
    deviceIDPattern *regexp.Regexp
}

func NewChargingRequestValidator() *ChargingRequestValidator {
    return &ChargingRequestValidator{
        orderNoPattern:  regexp.MustCompile(`^[A-Za-z0-9]{8,16}$`),
        deviceIDPattern: regexp.MustCompile(`^[A-Za-z0-9]{6,20}$`),
    }
}

func (v *ChargingRequestValidator) ValidateStartRequest(req *ChargingStartRequest) error {
    var errors []string
    
    // è®¾å¤‡IDéªŒè¯
    if !v.deviceIDPattern.MatchString(req.DeviceID) {
        errors = append(errors, "è®¾å¤‡IDæ ¼å¼æ— æ•ˆ")
    }
    
    // è®¢å•å·éªŒè¯
    if !v.orderNoPattern.MatchString(req.OrderNo) {
        errors = append(errors, "è®¢å•å·æ ¼å¼æ— æ•ˆ")
    }
    
    // ç«¯å£å·éªŒè¯
    if req.Port < 1 || req.Port > 32 {
        errors = append(errors, "ç«¯å£å·å¿…é¡»åœ¨1-32ä¹‹é—´")
    }
    
    // å……ç”µæ¨¡å¼éªŒè¯
    if req.Mode != 1 && req.Mode != 2 && req.Mode != 3 {
        errors = append(errors, "å……ç”µæ¨¡å¼æ— æ•ˆ")
    }
    
    // å……ç”µå‚æ•°éªŒè¯
    switch req.Mode {
    case 1: // æŒ‰æ—¶é•¿å……ç”µ
        if req.Value < 1 || req.Value > 1440 { // 1åˆ†é’Ÿåˆ°24å°æ—¶
            errors = append(errors, "å……ç”µæ—¶é•¿å¿…é¡»åœ¨1-1440åˆ†é’Ÿä¹‹é—´")
        }
    case 2: // æŒ‰ç”µé‡å……ç”µ
        if req.Value < 1 || req.Value > 100 { // 1kWhåˆ°100kWh
            errors = append(errors, "å……ç”µç”µé‡å¿…é¡»åœ¨1-100kWhä¹‹é—´")
        }
    case 3: // æŒ‰ä½™é¢å……ç”µ
        if req.Balance < 100 || req.Balance > 100000 { // 1å…ƒåˆ°1000å…ƒï¼ˆåˆ†ï¼‰
            errors = append(errors, "ä½™é¢å¿…é¡»åœ¨100-100000åˆ†ä¹‹é—´")
        }
    }
    
    if len(errors) > 0 {
        return fmt.Errorf("å‚æ•°éªŒè¯å¤±è´¥: %s", strings.Join(errors, "; "))
    }
    
    return nil
}
```

### 6.2 æ—¥å¿—æ•æ„Ÿä¿¡æ¯æ³„éœ² (CVE-Low-002)

#### 6.2.1 ä¿®å¤å»ºè®®
```go
type SecureLogger struct {
    logger *logrus.Logger
    maskPatterns map[string]*regexp.Regexp
}

func NewSecureLogger() *SecureLogger {
    return &SecureLogger{
        logger: logrus.New(),
        maskPatterns: map[string]*regexp.Regexp{
            "device_id": regexp.MustCompile(`"device_id":"([^"]*?)"`),
            "iccid":     regexp.MustCompile(`"iccid":"([^"]*?)"`),
            "order_no":  regexp.MustCompile(`"order_no":"([^"]*?)"`),
        },
    }
}

func (sl *SecureLogger) LogWithMasking(level logrus.Level, message string, fields logrus.Fields) {
    // åˆ›å»ºå®‰å…¨çš„å­—æ®µå‰¯æœ¬
    safeFields := make(logrus.Fields)
    for key, value := range fields {
        safeFields[key] = sl.maskSensitiveValue(key, value)
    }
    
    sl.logger.WithFields(safeFields).Log(level, message)
}

func (sl *SecureLogger) maskSensitiveValue(key string, value interface{}) interface{} {
    strValue, ok := value.(string)
    if !ok {
        return value
    }
    
    switch key {
    case "device_id", "iccid":
        if len(strValue) > 6 {
            return strValue[:3] + "***" + strValue[len(strValue)-3:]
        }
        return "***"
    case "order_no":
        if len(strValue) > 8 {
            return strValue[:4] + "***" + strValue[len(strValue)-4:]
        }
        return "***"
    default:
        return value
    }
}
```

## 7. ä¿®å¤ä¼˜å…ˆçº§å’Œè·¯çº¿å›¾

### 7.1 ç«‹å³ä¿®å¤ (1-2å‘¨)
1. **è®¢å•çŠ¶æ€ç®¡ç†æ¼æ´** - å®ç°å®Œæ•´çš„è®¢å•ç®¡ç†å™¨
2. **å……ç”µå‘½ä»¤å¹‚ç­‰æ€§** - æ·»åŠ çŠ¶æ€æ£€æŸ¥å’Œåˆ†å¸ƒå¼é”

### 7.2 çŸ­æœŸä¿®å¤ (3-4å‘¨)
1. **å……ç”µçŠ¶æ€æœº** - å®ç°å®Œæ•´çš„çŠ¶æ€æœºç®¡ç†
2. **åŠŸç‡æ§åˆ¶å®‰å…¨** - æ·»åŠ å®‰å…¨ä¿æŠ¤æœºåˆ¶

### 7.3 ä¸­æœŸæ”¹è¿› (1-2ä¸ªæœˆ)
1. **é€šçŸ¥å¯é æ€§** - å®ç°æ­»ä¿¡é˜Ÿåˆ—å’ŒæŒä¹…åŒ–
2. **å¿ƒè·³å»é‡ä¼˜åŒ–** - å®ç°è‡ªé€‚åº”å»é‡æœºåˆ¶

### 7.4 é•¿æœŸä¼˜åŒ– (3-6ä¸ªæœˆ)
1. **å‚æ•°éªŒè¯å¢å¼º** - å®Œå–„æ‰€æœ‰æ¥å£çš„å‚æ•°éªŒè¯
2. **æ—¥å¿—å®‰å…¨** - å®ç°æ•æ„Ÿä¿¡æ¯è„±æ•

## 8. æµ‹è¯•å»ºè®®

### 8.1 å•å…ƒæµ‹è¯•
- è®¢å•ç®¡ç†å™¨çš„å¹¶å‘æµ‹è¯•
- çŠ¶æ€æœºè½¬æ¢çš„è¾¹ç•Œæµ‹è¯•
- åŠŸç‡æ§åˆ¶çš„å®‰å…¨æµ‹è¯•

### 8.2 é›†æˆæµ‹è¯•
- å®Œæ•´å……ç”µæµç¨‹çš„ç«¯åˆ°ç«¯æµ‹è¯•
- å¼‚å¸¸åœºæ™¯çš„æ¢å¤æµ‹è¯•
- é«˜å¹¶å‘åœºæ™¯çš„å‹åŠ›æµ‹è¯•

### 8.3 å®‰å…¨æµ‹è¯•
- å‚æ•°æ³¨å…¥æ”»å‡»æµ‹è¯•
- çŠ¶æ€æœºç»•è¿‡æµ‹è¯•
- æƒé™è¶Šæƒæµ‹è¯•

## 9. æ€»ç»“

IOT-Zinxç³»ç»Ÿåœ¨å……ç”µä¸šåŠ¡æ–¹é¢å­˜åœ¨å¤šä¸ªå…³é”®çš„ä¸šåŠ¡é€»è¾‘æ¼æ´ï¼Œå…¶ä¸­è®¢å•çŠ¶æ€ç®¡ç†å’ŒçŠ¶æ€æœºç¼ºå¤±æ˜¯æœ€ä¸¥é‡çš„é—®é¢˜ã€‚å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥ä¿®å¤è¿™äº›é—®é¢˜ï¼ŒåŒæ—¶å»ºç«‹å®Œå–„çš„æµ‹è¯•å’Œç›‘æ§æœºåˆ¶ï¼Œç¡®ä¿ä¿®å¤çš„æœ‰æ•ˆæ€§å’Œç³»ç»Ÿçš„é•¿æœŸç¨³å®šæ€§ã€‚

é€šè¿‡å®æ–½æœ¬æ–‡æ¡£æå‡ºçš„ä¿®å¤å»ºè®®ï¼Œç³»ç»Ÿçš„å®‰å…¨æ€§ã€å¯é æ€§å’Œå¯ç»´æŠ¤æ€§å°†å¾—åˆ°æ˜¾è‘—æå‡ï¼Œèƒ½å¤Ÿæ›´å¥½åœ°æ”¯æ’‘å……ç”µæ¡©çš„å•†ä¸šåŒ–è¿è¥éœ€æ±‚ã€‚