# IoT-Zinxå¼€å‘æŒ‡å—

## ğŸ“‹ ç›®å½•ç»“æ„

```
iot-zinx/
â”œâ”€â”€ cmd/                    # åº”ç”¨ç¨‹åºå…¥å£
â”‚   â””â”€â”€ gateway/           # ç½‘å…³ä¸»ç¨‹åº
â”œâ”€â”€ internal/              # å†…éƒ¨åº”ç”¨ä»£ç 
â”‚   â”œâ”€â”€ adapters/         # é€‚é…å™¨å±‚
â”‚   â”œâ”€â”€ application/      # åº”ç”¨å±‚
â”‚   â”œâ”€â”€ domain/           # é¢†åŸŸå±‚
â”‚   â”œâ”€â”€ infrastructure/   # åŸºç¡€è®¾æ–½å±‚
â”‚   â””â”€â”€ ports/           # ç«¯å£å±‚
â”œâ”€â”€ pkg/                   # å¯å¤ç”¨çš„åº“ä»£ç 
â”‚   â”œâ”€â”€ core/            # æ ¸å¿ƒç»„ä»¶
â”‚   â”œâ”€â”€ protocol/        # åè®®å¤„ç†
â”‚   â”œâ”€â”€ network/         # ç½‘ç»œç»„ä»¶
â”‚   â””â”€â”€ constants/       # å¸¸é‡å®šä¹‰
â”œâ”€â”€ configs/              # é…ç½®æ–‡ä»¶
â”œâ”€â”€ docs/                 # æ–‡æ¡£
â”‚   â”œâ”€â”€ architecture/    # æ¶æ„æ–‡æ¡£
â”‚   â””â”€â”€ development/     # å¼€å‘æ–‡æ¡£
â””â”€â”€ tests/               # æµ‹è¯•æ–‡ä»¶
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚

- Go 1.19+
- Git
- Make (å¯é€‰)

### ç¼–è¯‘å’Œè¿è¡Œ

```bash
# å…‹éš†é¡¹ç›®
git clone <repository-url>
cd iot-zinx

# å®‰è£…ä¾èµ–
go mod tidy

# ç¼–è¯‘é¡¹ç›®
go build -o iot-zinx cmd/gateway/main.go

# è¿è¡Œé¡¹ç›®
./iot-zinx
```

### é…ç½®æ–‡ä»¶

ä¸»é…ç½®æ–‡ä»¶ä½äº `configs/gateway.yaml`ï¼š

```yaml
server:
  tcp_port: 8999
  http_port: 8080
  
device_connection:
  heartbeat_timeout_seconds: 300
  heartbeat_interval_seconds: 60
  
logging:
  level: "info"
  file_path: "logs/gateway.log"
```

## ğŸ”§ æ‰©å±•æ–°å‘½ä»¤

### 1. å®šä¹‰å‘½ä»¤å¸¸é‡

åœ¨ `pkg/constants/ap3000_commands.go` ä¸­æ·»åŠ æ–°å‘½ä»¤ï¼š

```go
const (
    CmdNewCommand = 0x99 // æ–°å‘½ä»¤æè¿°
)
```

### 2. åˆ›å»ºå‘½ä»¤å¤„ç†å™¨

åœ¨ `internal/infrastructure/zinx_server/handlers/` ä¸­åˆ›å»ºæ–°å¤„ç†å™¨ï¼š

```go
package handlers

import (
    "github.com/bujia-iot/iot-zinx/pkg/protocol"
    "github.com/aceld/zinx/ziface"
)

// NewCommandHandler æ–°å‘½ä»¤å¤„ç†å™¨
type NewCommandHandler struct {
    protocol.SimpleHandlerBase
}

// NewNewCommandHandler åˆ›å»ºæ–°å‘½ä»¤å¤„ç†å™¨
func NewNewCommandHandler() *NewCommandHandler {
    return &NewCommandHandler{}
}

// Handle å¤„ç†æ–°å‘½ä»¤
func (h *NewCommandHandler) Handle(request ziface.IRequest) {
    // 1. æå–è§£ç åçš„å¸§æ•°æ®
    decodedFrame, err := h.ExtractDecodedFrame(request)
    if err != nil {
        h.HandleError(request, err, "æå–å¸§æ•°æ®å¤±è´¥")
        return
    }

    // 2. éªŒè¯å¸§æ•°æ®
    if err := h.ValidateFrame(decodedFrame); err != nil {
        h.HandleError(request, err, "å¸§æ•°æ®éªŒè¯å¤±è´¥")
        return
    }

    // 3. å¤„ç†ä¸šåŠ¡é€»è¾‘
    if err := h.processNewCommand(decodedFrame, request.GetConnection()); err != nil {
        h.HandleError(request, err, "å¤„ç†æ–°å‘½ä»¤å¤±è´¥")
        return
    }

    // 4. å‘é€å“åº”
    h.SendSuccessResponse(request, []byte{0x01}) // æˆåŠŸå“åº”
}

// processNewCommand å¤„ç†æ–°å‘½ä»¤çš„å…·ä½“é€»è¾‘
func (h *NewCommandHandler) processNewCommand(frame *protocol.DecodedDNYFrame, conn ziface.IConnection) error {
    // å®ç°å…·ä½“çš„ä¸šåŠ¡é€»è¾‘
    return nil
}
```

### 3. æ³¨å†Œè·¯ç”±

åœ¨ `internal/infrastructure/zinx_server/handlers/router.go` ä¸­æ³¨å†Œï¼š

```go
server.AddRouter(constants.CmdNewCommand, NewNewCommandHandler()) // 0x99 æ–°å‘½ä»¤
```

## ğŸ”Œ æ·»åŠ æ–°åè®®

### 1. æ‰©å±•åè®®è§£æ

åœ¨ `pkg/protocol/dny_protocol_parser.go` ä¸­æ‰©å±•ï¼š

```go
// åœ¨ParseDNYProtocolDataå‡½æ•°ä¸­æ·»åŠ æ–°åè®®è¯†åˆ«
func (p *DNYProtocolParser) ParseDNYProtocolData(data []byte) (*DNYParseResult, error) {
    // ç°æœ‰åè®®è¯†åˆ«é€»è¾‘...
    
    // æ·»åŠ æ–°åè®®è¯†åˆ«
    if len(data) >= 4 && string(data[:4]) == "NEW_" {
        return &DNYParseResult{
            Type:    "NEW_PROTOCOL",
            MsgID:   MsgIDNewProtocol,
            Data:    data,
            IsValid: true,
        }, nil
    }
    
    // å…¶ä»–é€»è¾‘...
}
```

### 2. å®šä¹‰æ–°æ¶ˆæ¯ç±»å‹

```go
const (
    MsgIDNewProtocol = 9999 // æ–°åè®®æ¶ˆæ¯ID
)
```

### 3. å®ç°ç¼–è§£ç å‡½æ•°

```go
// EncodeNewProtocol ç¼–ç æ–°åè®®æ•°æ®
func EncodeNewProtocol(data interface{}) ([]byte, error) {
    // å®ç°ç¼–ç é€»è¾‘
    return nil, nil
}

// DecodeNewProtocol è§£ç æ–°åè®®æ•°æ®
func DecodeNewProtocol(data []byte) (interface{}, error) {
    // å®ç°è§£ç é€»è¾‘
    return nil, nil
}
```

## ğŸ”— é›†æˆç¬¬ä¸‰æ–¹ç³»ç»Ÿ

### 1. å®ç°é€šçŸ¥æ¥å£

åœ¨ `pkg/notification/` ä¸­åˆ›å»ºæ–°çš„é€šçŸ¥å®ç°ï¼š

```go
package notification

// ThirdPartyNotifier ç¬¬ä¸‰æ–¹é€šçŸ¥å™¨æ¥å£
type ThirdPartyNotifier interface {
    NotifyDeviceOnline(deviceID string, data map[string]interface{}) error
    NotifyHeartbeat(deviceID string, data map[string]interface{}) error
    NotifySettlement(deviceID string, data map[string]interface{}) error
}

// NewThirdPartyNotifier æ–°ç¬¬ä¸‰æ–¹é€šçŸ¥å™¨
type NewThirdPartyNotifier struct {
    endpoint string
    apiKey   string
}

// NewNewThirdPartyNotifier åˆ›å»ºæ–°ç¬¬ä¸‰æ–¹é€šçŸ¥å™¨
func NewNewThirdPartyNotifier(endpoint, apiKey string) *NewThirdPartyNotifier {
    return &NewThirdPartyNotifier{
        endpoint: endpoint,
        apiKey:   apiKey,
    }
}

// NotifyDeviceOnline é€šçŸ¥è®¾å¤‡ä¸Šçº¿
func (n *NewThirdPartyNotifier) NotifyDeviceOnline(deviceID string, data map[string]interface{}) error {
    // å®ç°é€šçŸ¥é€»è¾‘
    return nil
}
```

### 2. é…ç½®ç¬¬ä¸‰æ–¹å¹³å°

åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ ç¬¬ä¸‰æ–¹å¹³å°é…ç½®ï¼š

```yaml
third_party:
  new_platform:
    enabled: true
    endpoint: "https://api.newplatform.com/notify"
    api_key: "your-api-key"
    timeout: 30s
```

### 3. æ³¨å†Œé€šçŸ¥å™¨

åœ¨åº”ç”¨å¯åŠ¨æ—¶æ³¨å†Œé€šçŸ¥å™¨ï¼š

```go
// åœ¨main.goæˆ–ç›¸å…³åˆå§‹åŒ–ä»£ç ä¸­
notifier := notification.NewNewThirdPartyNotifier(
    config.ThirdParty.NewPlatform.Endpoint,
    config.ThirdParty.NewPlatform.APIKey,
)

// æ³¨å†Œåˆ°é€šçŸ¥ç®¡ç†å™¨
notificationManager.RegisterNotifier("new_platform", notifier)
```

## ğŸ§ª æµ‹è¯•æŒ‡å—

### å•å…ƒæµ‹è¯•

```go
package handlers

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestNewCommandHandler_Handle(t *testing.T) {
    // åˆ›å»ºæµ‹è¯•ç”¨ä¾‹
    handler := NewNewCommandHandler()
    
    // æ¨¡æ‹Ÿè¯·æ±‚æ•°æ®
    // ...
    
    // æ‰§è¡Œæµ‹è¯•
    // ...
    
    // éªŒè¯ç»“æœ
    assert.NoError(t, err)
}
```

### é›†æˆæµ‹è¯•

```go
func TestNewCommandIntegration(t *testing.T) {
    // å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
    server := startTestServer()
    defer server.Stop()
    
    // æ¨¡æ‹Ÿè®¾å¤‡è¿æ¥
    conn := connectTestDevice()
    defer conn.Close()
    
    // å‘é€æµ‹è¯•å‘½ä»¤
    response := sendTestCommand(conn, testData)
    
    // éªŒè¯å“åº”
    assert.Equal(t, expectedResponse, response)
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ä¼˜åŒ–

```go
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
var framePool = sync.Pool{
    New: func() interface{} {
        return &DecodedDNYFrame{}
    },
}

// è·å–å¯¹è±¡
frame := framePool.Get().(*DecodedDNYFrame)
defer framePool.Put(frame)
```

### å¹¶å‘ä¼˜åŒ–

```go
// ä½¿ç”¨worker poolå¤„ç†å¹¶å‘è¯·æ±‚
type WorkerPool struct {
    workers chan chan Job
    jobQueue chan Job
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.maxWorkers; i++ {
        worker := NewWorker(wp.workers)
        worker.Start()
    }
}
```

## ğŸ” è°ƒè¯•æŠ€å·§

### æ—¥å¿—è°ƒè¯•

```go
import "github.com/sirupsen/logrus"

// ç»“æ„åŒ–æ—¥å¿—
logrus.WithFields(logrus.Fields{
    "deviceID": deviceID,
    "command":  command,
    "data":     data,
}).Info("å¤„ç†è®¾å¤‡å‘½ä»¤")
```

### æ€§èƒ½åˆ†æ

```go
import _ "net/http/pprof"

// åœ¨mainå‡½æ•°ä¸­å¯ç”¨pprof
go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```

## ğŸ“‹ ä»£ç è§„èŒƒ

### å‘½åè§„èŒƒ

- åŒ…åï¼šå°å†™ï¼Œç®€çŸ­ï¼Œæœ‰æ„ä¹‰
- å‡½æ•°åï¼šé©¼å³°å‘½åï¼ŒåŠ¨è¯å¼€å¤´
- å˜é‡åï¼šé©¼å³°å‘½åï¼Œåè¯
- å¸¸é‡åï¼šå¤§å†™ï¼Œä¸‹åˆ’çº¿åˆ†éš”

### é”™è¯¯å¤„ç†

```go
// ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å¼
func processData(data []byte) error {
    if len(data) == 0 {
        return fmt.Errorf("æ•°æ®ä¸ºç©º")
    }
    
    // å¤„ç†é€»è¾‘...
    
    return nil
}
```

### æ³¨é‡Šè§„èŒƒ

```go
// ProcessCommand å¤„ç†è®¾å¤‡å‘½ä»¤
// å‚æ•°:
//   - command: å‘½ä»¤ç±»å‹
//   - data: å‘½ä»¤æ•°æ®
// è¿”å›:
//   - error: å¤„ç†é”™è¯¯
func ProcessCommand(command uint8, data []byte) error {
    // å®ç°é€»è¾‘...
}
```

## ğŸš€ éƒ¨ç½²æŒ‡å—

### Dockeréƒ¨ç½²

```dockerfile
FROM golang:1.19-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o iot-zinx cmd/gateway/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/iot-zinx .
COPY --from=builder /app/configs ./configs
CMD ["./iot-zinx"]
```

### ç³»ç»ŸæœåŠ¡

```ini
[Unit]
Description=IoT-Zinx Gateway
After=network.target

[Service]
Type=simple
User=iot-zinx
WorkingDirectory=/opt/iot-zinx
ExecStart=/opt/iot-zinx/iot-zinx
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¶é—´**: 2025-08-07  
**é€‚ç”¨ç‰ˆæœ¬**: IoT-Zinx v1.0+  
**ç»´æŠ¤çŠ¶æ€**: æ´»è·ƒç»´æŠ¤ä¸­
