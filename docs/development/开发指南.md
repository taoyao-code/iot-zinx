# IoT-Zinx开发指南

## 📋 目录结构

```
iot-zinx/
├── cmd/                    # 应用程序入口
│   └── gateway/           # 网关主程序
├── internal/              # 内部应用代码
│   ├── adapters/         # 适配器层
│   ├── application/      # 应用层
│   ├── domain/           # 领域层
│   ├── infrastructure/   # 基础设施层
│   └── ports/           # 端口层
├── pkg/                   # 可复用的库代码
│   ├── core/            # 核心组件
│   ├── protocol/        # 协议处理
│   ├── network/         # 网络组件
│   └── constants/       # 常量定义
├── configs/              # 配置文件
├── docs/                 # 文档
│   ├── architecture/    # 架构文档
│   └── development/     # 开发文档
└── tests/               # 测试文件
```

## 🚀 快速开始

### 环境要求

- Go 1.19+
- Git
- Make (可选)

### 编译和运行

```bash
# 克隆项目
git clone <repository-url>
cd iot-zinx

# 安装依赖
go mod tidy

# 编译项目
go build -o iot-zinx cmd/gateway/main.go

# 运行项目
./iot-zinx
```

### 配置文件

主配置文件位于 `configs/gateway.yaml`：

```yaml
server:
  tcp_port: 8999
  http_port: 8080
  
device_connection:
  heartbeat_timeout_seconds: 300
  heartbeat_interval_seconds: 60
  
logging:
  level: "info"
  file_path: "logs/gateway.log"
```

## 🔧 扩展新命令

### 1. 定义命令常量

在 `pkg/constants/ap3000_commands.go` 中添加新命令：

```go
const (
    CmdNewCommand = 0x99 // 新命令描述
)
```

### 2. 创建命令处理器

在 `internal/infrastructure/zinx_server/handlers/` 中创建新处理器：

```go
package handlers

import (
    "github.com/bujia-iot/iot-zinx/pkg/protocol"
    "github.com/aceld/zinx/ziface"
)

// NewCommandHandler 新命令处理器
type NewCommandHandler struct {
    protocol.SimpleHandlerBase
}

// NewNewCommandHandler 创建新命令处理器
func NewNewCommandHandler() *NewCommandHandler {
    return &NewCommandHandler{}
}

// Handle 处理新命令
func (h *NewCommandHandler) Handle(request ziface.IRequest) {
    // 1. 提取解码后的帧数据
    decodedFrame, err := h.ExtractDecodedFrame(request)
    if err != nil {
        h.HandleError(request, err, "提取帧数据失败")
        return
    }

    // 2. 验证帧数据
    if err := h.ValidateFrame(decodedFrame); err != nil {
        h.HandleError(request, err, "帧数据验证失败")
        return
    }

    // 3. 处理业务逻辑
    if err := h.processNewCommand(decodedFrame, request.GetConnection()); err != nil {
        h.HandleError(request, err, "处理新命令失败")
        return
    }

    // 4. 发送响应
    h.SendSuccessResponse(request, []byte{0x01}) // 成功响应
}

// processNewCommand 处理新命令的具体逻辑
func (h *NewCommandHandler) processNewCommand(frame *protocol.DecodedDNYFrame, conn ziface.IConnection) error {
    // 实现具体的业务逻辑
    return nil
}
```

### 3. 注册路由

在 `internal/infrastructure/zinx_server/handlers/router.go` 中注册：

```go
server.AddRouter(constants.CmdNewCommand, NewNewCommandHandler()) // 0x99 新命令
```

## 🔌 添加新协议

### 1. 扩展协议解析

在 `pkg/protocol/dny_protocol_parser.go` 中扩展：

```go
// 在ParseDNYProtocolData函数中添加新协议识别
func (p *DNYProtocolParser) ParseDNYProtocolData(data []byte) (*DNYParseResult, error) {
    // 现有协议识别逻辑...
    
    // 添加新协议识别
    if len(data) >= 4 && string(data[:4]) == "NEW_" {
        return &DNYParseResult{
            Type:    "NEW_PROTOCOL",
            MsgID:   MsgIDNewProtocol,
            Data:    data,
            IsValid: true,
        }, nil
    }
    
    // 其他逻辑...
}
```

### 2. 定义新消息类型

```go
const (
    MsgIDNewProtocol = 9999 // 新协议消息ID
)
```

### 3. 实现编解码函数

```go
// EncodeNewProtocol 编码新协议数据
func EncodeNewProtocol(data interface{}) ([]byte, error) {
    // 实现编码逻辑
    return nil, nil
}

// DecodeNewProtocol 解码新协议数据
func DecodeNewProtocol(data []byte) (interface{}, error) {
    // 实现解码逻辑
    return nil, nil
}
```

## 🔗 集成第三方系统

### 1. 实现通知接口

在 `pkg/notification/` 中创建新的通知实现：

```go
package notification

// ThirdPartyNotifier 第三方通知器接口
type ThirdPartyNotifier interface {
    NotifyDeviceOnline(deviceID string, data map[string]interface{}) error
    NotifyHeartbeat(deviceID string, data map[string]interface{}) error
    NotifySettlement(deviceID string, data map[string]interface{}) error
}

// NewThirdPartyNotifier 新第三方通知器
type NewThirdPartyNotifier struct {
    endpoint string
    apiKey   string
}

// NewNewThirdPartyNotifier 创建新第三方通知器
func NewNewThirdPartyNotifier(endpoint, apiKey string) *NewThirdPartyNotifier {
    return &NewThirdPartyNotifier{
        endpoint: endpoint,
        apiKey:   apiKey,
    }
}

// NotifyDeviceOnline 通知设备上线
func (n *NewThirdPartyNotifier) NotifyDeviceOnline(deviceID string, data map[string]interface{}) error {
    // 实现通知逻辑
    return nil
}
```

### 2. 配置第三方平台

在配置文件中添加第三方平台配置：

```yaml
third_party:
  new_platform:
    enabled: true
    endpoint: "https://api.newplatform.com/notify"
    api_key: "your-api-key"
    timeout: 30s
```

### 3. 注册通知器

在应用启动时注册通知器：

```go
// 在main.go或相关初始化代码中
notifier := notification.NewNewThirdPartyNotifier(
    config.ThirdParty.NewPlatform.Endpoint,
    config.ThirdParty.NewPlatform.APIKey,
)

// 注册到通知管理器
notificationManager.RegisterNotifier("new_platform", notifier)
```

## 🧪 测试指南

### 单元测试

```go
package handlers

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestNewCommandHandler_Handle(t *testing.T) {
    // 创建测试用例
    handler := NewNewCommandHandler()
    
    // 模拟请求数据
    // ...
    
    // 执行测试
    // ...
    
    // 验证结果
    assert.NoError(t, err)
}
```

### 集成测试

```go
func TestNewCommandIntegration(t *testing.T) {
    // 启动测试服务器
    server := startTestServer()
    defer server.Stop()
    
    // 模拟设备连接
    conn := connectTestDevice()
    defer conn.Close()
    
    // 发送测试命令
    response := sendTestCommand(conn, testData)
    
    // 验证响应
    assert.Equal(t, expectedResponse, response)
}
```

## 📊 性能优化

### 内存优化

```go
// 使用对象池减少内存分配
var framePool = sync.Pool{
    New: func() interface{} {
        return &DecodedDNYFrame{}
    },
}

// 获取对象
frame := framePool.Get().(*DecodedDNYFrame)
defer framePool.Put(frame)
```

### 并发优化

```go
// 使用worker pool处理并发请求
type WorkerPool struct {
    workers chan chan Job
    jobQueue chan Job
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.maxWorkers; i++ {
        worker := NewWorker(wp.workers)
        worker.Start()
    }
}
```

## 🔍 调试技巧

### 日志调试

```go
import "github.com/sirupsen/logrus"

// 结构化日志
logrus.WithFields(logrus.Fields{
    "deviceID": deviceID,
    "command":  command,
    "data":     data,
}).Info("处理设备命令")
```

### 性能分析

```go
import _ "net/http/pprof"

// 在main函数中启用pprof
go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```

## 📋 代码规范

### 命名规范

- 包名：小写，简短，有意义
- 函数名：驼峰命名，动词开头
- 变量名：驼峰命名，名词
- 常量名：大写，下划线分隔

### 错误处理

```go
// 统一的错误处理模式
func processData(data []byte) error {
    if len(data) == 0 {
        return fmt.Errorf("数据为空")
    }
    
    // 处理逻辑...
    
    return nil
}
```

### 注释规范

```go
// ProcessCommand 处理设备命令
// 参数:
//   - command: 命令类型
//   - data: 命令数据
// 返回:
//   - error: 处理错误
func ProcessCommand(command uint8, data []byte) error {
    // 实现逻辑...
}
```

## 🚀 部署指南

### Docker部署

```dockerfile
FROM golang:1.19-alpine AS builder
WORKDIR /app
COPY . .
RUN go build -o iot-zinx cmd/gateway/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/iot-zinx .
COPY --from=builder /app/configs ./configs
CMD ["./iot-zinx"]
```

### 系统服务

```ini
[Unit]
Description=IoT-Zinx Gateway
After=network.target

[Service]
Type=simple
User=iot-zinx
WorkingDirectory=/opt/iot-zinx
ExecStart=/opt/iot-zinx/iot-zinx
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

---

**文档版本**: v1.0  
**更新时间**: 2025-08-07  
**适用版本**: IoT-Zinx v1.0+  
**维护状态**: 活跃维护中
