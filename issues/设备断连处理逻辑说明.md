# 设备断连处理逻辑说明

## 概述

本文档说明 IoT 系统中设备断连处理的逻辑架构，特别是`HandleDeviceDisconnect`和`SuspendSession`两个方法的职责划分和调用关系。

## 当前调用链分析

### 连接断开事件流

```
1. 物理连接断开/心跳超时
   ↓
2. ConnectionHooks.OnConnectionStop()
   ↓
3. TCPMonitor.OnConnectionClosed()
   ↓
4. SessionManager.HandleDeviceDisconnect() (直接设为 Offline)

   【并行路径】
   DeviceMonitor.OnDeviceDisconnect()
   ↓
   SessionManager.SuspendSession() (设为 Reconnecting)
```

### 问题识别

1. **重复调用**：同一断开事件可能触发两个不同的处理路径
2. **状态冲突**：`HandleDeviceDisconnect`设置状态为`Offline`，`SuspendSession`设置为`Reconnecting`
3. **职责模糊**：两个方法的使用场景不够明确

## 优化后的处理逻辑

### 方法职责定义

#### SuspendSession (临时断开)

- **使用场景**：连接意外断开，设备预期会重连
- **状态转换**：`Online` → `Reconnecting`
- **过期设置**：更新`ExpiresAt`字段，允许在超时时间内重连
- **调用时机**：网络波动、临时连接问题

#### HandleDeviceDisconnect (最终断开)

- **使用场景**：设备确认离线，不再期望短期内重连
- **状态转换**：`Reconnecting` → `Offline` 或 `Online` → `Offline`
- **过期设置**：设置较长的`ExpiresAt`或标记为永久离线
- **调用时机**：设备主动下线、长期无响应、管理员手动断开

### 统一调用流程

```
连接断开事件
   ↓
判断断开类型
   ↓
┌─────────────────┬─────────────────┐
│   临时断开      │     最终断开    │
│                 │                 │
│ SuspendSession  │ HandleDevice-   │
│                 │ Disconnect      │
│                 │                 │
│ Reconnecting    │ Offline         │
└─────────────────┴─────────────────┘
```

## 状态转换规则

### 设备会话状态常量

```go
const (
    SessionStatusActive      = "active"      // 活跃状态
    SessionStatusSuspended   = "suspended"   // 挂起状态（等待重连）
    SessionStatusOffline     = "offline"     // 离线状态
    SessionStatusExpired     = "expired"     // 过期状态
)
```

### 状态转换矩阵

| 当前状态  | 事件     | 目标状态  | 处理方法               |
| --------- | -------- | --------- | ---------------------- |
| Active    | 临时断开 | Suspended | SuspendSession         |
| Active    | 最终断开 | Offline   | HandleDeviceDisconnect |
| Suspended | 重连成功 | Active    | ResumeSession          |
| Suspended | 重连超时 | Offline   | HandleDeviceDisconnect |
| Offline   | 重新上线 | Active    | CreateSession          |

## 调用规范

### 1. 连接断开处理统一入口

**文件**: `pkg/monitor/tcp_monitor.go`

```go
func (tm *TCPMonitor) OnConnectionClosed(conn ziface.IConnection) {
    // ... 清理连接映射逻辑

    // 分析断开原因
    reason := getDisconnectReason(conn)

    for deviceID := range deviceIDsToNotify {
        // 根据断开原因选择处理方式
        if isTemporaryDisconnect(reason) {
            // 临时断开：挂起会话，期望重连
            tm.sessionManager.SuspendSession(deviceID)
        } else {
            // 最终断开：设备离线
            tm.sessionManager.HandleDeviceDisconnect(deviceID)
        }
    }
}
```

### 2. 断开原因判断逻辑

```go
func isTemporaryDisconnect(reason string) bool {
    temporaryReasons := []string{
        "i/o timeout",
        "connection reset by peer",
        "network unreachable",
    }

    for _, tempReason := range temporaryReasons {
        if strings.Contains(reason, tempReason) {
            return true
        }
    }
    return false
}
```

### 3. 设备监控器处理

**文件**: `pkg/monitor/device_monitor.go`

```go
func (dm *DeviceMonitor) OnDeviceDisconnect(deviceID string, conn ziface.IConnection, reason string) {
    // 设备监控器不直接调用会话状态变更
    // 而是记录监控日志，处理设备组状态

    // 更新设备组状态
    dm.updateDeviceGroupStatus(deviceID, conn)

    // 触发监控事件回调
    if dm.onDeviceTimeout != nil {
        dm.onDeviceTimeout(deviceID, time.Now())
    }
}
```

## 最佳实践

1. **单一入口**：所有连接断开事件都通过`TCPMonitor.OnConnectionClosed`处理
2. **职责分离**：`DeviceMonitor`负责监控，`SessionManager`负责状态管理
3. **避免重复**：同一断开事件只调用一次状态变更方法
4. **明确意图**：通过断开原因判断选择合适的处理方法
5. **日志完整**：记录状态转换的完整路径，便于问题排查

## 配置参数

```go
type SessionConfig struct {
    // 会话超时时间（挂起状态允许的重连时间）
    SessionTimeout        time.Duration `default:"30m"`

    // 重连尝试次数
    MaxReconnectAttempts  int           `default:"3"`

    // 离线保留时间（离线状态会话保留时间）
    OfflineRetentionTime  time.Duration `default:"24h"`
}
```

## 监控指标

建议增加以下监控指标：

- `session_suspend_total`: 会话挂起次数
- `session_disconnect_total`: 会话断开次数
- `session_resume_total`: 会话恢复次数
- `session_timeout_total`: 会话超时次数

---

_文档版本_: v1.0  
_更新时间_: 2025 年 6 月 12 日  
_维护者_: IoT 系统开发团队
