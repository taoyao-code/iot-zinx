# 第三方平台通知系统实施计划（简化版）

## 项目概述

基于 AP3000 协议和系统日志分析，实施完整的充电流程审计系统和第三方平台异步通知机制。确保 100%数据一致性，不影响现有系统性能。

## 实施背景

### 当前问题分析

1. **缺乏完整审计**: 充电流程缺乏详细的事件记录和追踪
2. **通知机制不完善**: 第三方平台通知存在失败重试问题
3. **数据一致性风险**: 协议处理和业务逻辑之间缺乏一致性保证
4. **监控能力不足**: 缺乏实时的充电流程监控和告警

### 目标成果

1. **完整审计系统**: 记录从设备上线到充电结算的完整流程
2. **可靠通知系统**: 异步、可重试的第三方平台通知机制
3. **实时监控**: 充电流程实时监控和异常告警
4. **数据一致性**: 确保协议数据和业务数据的完全一致

## 详细实施计划

### 第一阶段：基础设施搭建 (Week 1-2)

#### Week 1: 核心组件设计

- [ ] **Day 1-2**: 审计服务核心接口设计
  - 定义 `ChargingAuditService` 接口
  - 设计事件数据结构 `AuditEvent`
  - 设计充电会话结构 `ChargingSession`
- [ ] **Day 3-4**: 通知管理器接口设计

  - 定义 `NotificationManager` 接口
  - 设计通知事件结构 `NotificationEvent`
  - 设计配置结构 `NotificationConfig`

- [x] **Day 5**: Redis 存储设计和配置
  - 设计 Redis 数据结构
  - 配置 TTL 策略
  - 集成到现有 Redis 客户端

#### Week 2: 核心实现

- [x] **Day 1-3**: 实现 `ChargingAuditService`

  ```go
  type ChargingAuditService struct {
      storage     *RedisAuditStorage  // 复用现有Redis
      cache       ISessionCache
      eventQueue  chan *AuditEvent
      batchSize   int
      flushInterval time.Duration
  }
  ```

- [x] **Day 4-5**: 实现 `NotificationManager`
  ```go
  type NotificationManager struct {
      config      *NotificationConfig
      eventQueue  chan *NotificationEvent
      workers     []*NotificationWorker
      httpClient  *http.Client
      retryQueue  chan *RetryableEvent
  }
  ```

### 第二阶段：系统集成 (Week 3-4)

#### Week 3: 协议处理器集成

- [ ] **Day 1**: 集成设备注册处理器

  ```go
  // 在 DeviceRegisterHandler 中添加
  func (h *DeviceRegisterHandler) processWithAudit(deviceID string, registerData *RegisterData) {
      // 原有逻辑...

      // 添加审计
      h.auditService.RecordDeviceEvent("device_register", deviceID, registerData)
      h.notificationManager.NotifyDeviceOnline(deviceID, registerData)
  }
  ```

- [ ] **Day 2**: 集成心跳处理器

  ```go
  // 在 HeartbeatHandler 中添加
  func (h *HeartbeatHandler) processWithAudit(deviceID string, heartbeatData *HeartbeatData) {
      oldStatus := h.getPortStatus(deviceID, heartbeatData.PortNumber)

      // 原有逻辑...

      // 检查状态变化并审计
      if oldStatus != heartbeatData.PortStatus {
          h.auditService.RecordStatusChange(deviceID, heartbeatData.PortNumber, oldStatus, heartbeatData.PortStatus)
          h.handlePortStatusChange(deviceID, heartbeatData.PortNumber, oldStatus, heartbeatData.PortStatus)
      }
  }
  ```

- [ ] **Day 3**: 集成功率心跳处理器

  ```go
  // 在 PowerHeartbeatHandler 中添加
  func (h *PowerHeartbeatHandler) processWithAudit(deviceID string, powerData *PowerHeartbeatData) {
      // 原有逻辑...

      // 记录功率数据
      h.auditService.RecordPowerData(deviceID, powerData)
      h.notificationManager.NotifyChargingProgress(deviceID, powerData)
  }
  ```

- [ ] **Day 4**: 集成结算处理器

  ```go
  // 在 SettlementHandler 中添加
  func (h *SettlementHandler) processWithAudit(deviceID string, settlementData *SettlementData) {
      // 原有逻辑...

      // 记录结算数据并结束会话
      h.auditService.RecordSettlement(deviceID, settlementData)
      h.auditService.EndChargingSession(deviceID, settlementData.PortNumber, settlementData)
      h.notificationManager.NotifySettlement(deviceID, settlementData)
  }
  ```

- [ ] **Day 5**: 系统配置集成

  ```yaml
  # 已集成到 configs/gateway.yaml
  audit:
    enabled: true
    batch_size: 100
    flush_interval: 30s
    storage:
      type: "redis"
      key_prefix: "audit:" # 复用现有Redis，使用键前缀
      ttl:
        sessions: "720h" # 30天
        events: "168h" # 7天
        notifications: "72h" # 3天

  notification:
    enabled: true
    queue_size: 10000
    worker_count: 5
    endpoints:
      - name: "business_platform"
        url: "${BUSINESS_WEBHOOK_URL}"
        api_key: "${BUSINESS_API_KEY}"
        timeout: 10s
        retry_count: 3
  ```

#### Week 4: 错误处理和重试机制

- [ ] **Day 1-2**: 实现重试机制

  ```go
  type RetryManager struct {
      retryQueue    chan *RetryableEvent
      deadLetterQueue chan *DeadLetterEvent
      maxAttempts   int
      backoffStrategy BackoffStrategy
  }
  ```

- [ ] **Day 3**: 实现熔断器

  ```go
  type CircuitBreaker struct {
      failureThreshold int
      successThreshold int
      timeout         time.Duration
      state           CircuitState
      failureCount    int
      successCount    int
  }
  ```

- [ ] **Day 4**: 实现限流器

  ```go
  type RateLimiter struct {
      tokensPerSecond int
      bucketSize     int
      tokens         int
      lastRefill     time.Time
      mutex          sync.Mutex
  }
  ```

- [ ] **Day 5**: 集成测试和调试

### 第三阶段：监控和优化 (Week 5-6)

#### Week 5: 监控系统

- [ ] **Day 1-2**: 实现指标收集

  ```go
  type MetricsCollector struct {
      auditMetrics        *AuditMetrics
      notificationMetrics *NotificationMetrics
      systemMetrics      *SystemMetrics
  }

  type AuditMetrics struct {
      TotalEvents       int64
      EventsByType      map[string]int64
      ProcessingTime    time.Duration
      QueueLength       int
  }
  ```

- [ ] **Day 3**: 实现健康检查

  ```go
  type HealthChecker struct {
      auditService      *ChargingAuditService
      notificationMgr   *NotificationManager
      database          *sql.DB
      checkInterval     time.Duration
  }
  ```

- [ ] **Day 4**: 实现告警系统

  ```go
  type AlertManager struct {
      rules           []AlertRule
      notifiers       []AlertNotifier
      silenceManager  *SilenceManager
  }
  ```

- [ ] **Day 5**: 监控面板集成

#### Week 6: 性能优化

- [ ] **Day 1**: 批量处理优化

  - 实现事件批量写入
  - 优化数据库连接池
  - 实现内存池管理

- [ ] **Day 2**: 缓存优化

  - 实现会话缓存
  - 优化状态查询缓存
  - 实现 LRU 缓存策略

- [ ] **Day 3**: 并发优化

  - 优化工作器池
  - 实现无锁队列
  - 优化协程管理

- [ ] **Day 4**: 压力测试

  - 模拟高并发场景
  - 性能基准测试
  - 内存泄漏检查

- [ ] **Day 5**: 优化调整和文档完善

### 第四阶段：测试和部署 (Week 7-8)

#### Week 7: 全面测试

- [ ] **Day 1-2**: 单元测试

  ```go
  func TestChargingAuditService(t *testing.T) {
      // 测试审计服务各个功能
  }

  func TestNotificationManager(t *testing.T) {
      // 测试通知管理器各个功能
  }
  ```

- [ ] **Day 3**: 集成测试

  ```go
  func TestFullChargingFlow(t *testing.T) {
      // 测试完整的充电流程审计和通知
  }
  ```

- [ ] **Day 4**: 端到端测试

  - 模拟真实设备连接
  - 测试完整充电流程
  - 验证第三方平台通知

- [ ] **Day 5**: 性能测试和调优

#### Week 8: 部署和上线

- [ ] **Day 1**: 部署环境准备

  - Redis 配置优化
  - 配置文件准备
  - 依赖项检查

- [ ] **Day 2**: 灰度部署

  - 选择部分设备进行测试
  - 监控系统运行状态
  - 收集反馈和调整

- [ ] **Day 3**: 全量部署

  - 逐步扩展到所有设备
  - 实时监控系统状态
  - 确保系统稳定运行

- [ ] **Day 4**: 运维文档编写

  - 部署指南
  - 运维手册
  - 故障排查指南

- [ ] **Day 5**: 团队培训和交接

## 关键技术决策

### 1. 架构设计原则

- **异步优先**: 所有审计和通知操作都异步执行，不阻塞主流程
- **可扩展性**: 支持水平扩展，可以增加工作器数量
- **可靠性**: 多层重试机制，确保数据不丢失
- **监控性**: 全面的指标收集和告警机制

### 2. 数据一致性保证

- **事务控制**: 关键操作使用数据库事务
- **幂等设计**: 所有操作都是幂等的，避免重复处理
- **版本控制**: 使用版本号防止并发冲突

### 3. 性能优化策略

- **批量处理**: 事件批量写入数据库
- **内存池**: 减少对象分配开销
- **连接池**: 优化数据库连接管理
- **缓存策略**: 合理使用缓存减少数据库压力

## 风险控制

### 1. 系统风险

- **性能影响**: 通过异步处理和性能测试确保不影响主系统
- **内存泄漏**: 通过内存池和定期检查防止内存泄漏
- **死锁风险**: 合理的锁设计和超时机制

### 2. 数据风险

- **数据丢失**: 多层备份和重试机制
- **数据不一致**: 事务控制和版本管理
- **数据泄露**: 敏感数据加密和访问控制

### 3. 集成风险

- **接口变更**: 版本兼容性检查
- **配置错误**: 配置验证和默认值
- **第三方依赖**: 熔断器和降级策略

## 验收标准

### 1. 功能验收

- [ ] 完整记录充电流程的所有关键事件
- [ ] 成功发送第三方平台通知，成功率 > 99%
- [ ] 支持重试机制，最终成功率 > 99.9%
- [ ] 提供实时监控和告警功能

### 2. 性能验收

- [ ] 审计功能对主系统性能影响 < 5%
- [ ] 通知延迟 < 10 秒（正常情况下）
- [ ] 系统可处理 10000+ 并发设备
- [ ] 内存使用增长 < 20%

### 3. 可靠性验收

- [ ] 系统 7\*24 小时稳定运行
- [ ] 异常恢复时间 < 30 秒
- [ ] 数据零丢失
- [ ] 支持优雅停机和重启

## 上下文和预期结果

### 上下文

当前 IoT-Zinx 系统已具备完整的充电设备管理和协议处理能力，但缺乏完善的审计和通知机制。随着业务规模扩大，需要:

1. 完整的充电流程追踪和审计
2. 可靠的第三方平台集成
3. 实时的业务监控和告警
4. 完善的数据分析支持

### 预期结果

1. **业务价值**: 提供完整的充电数据分析和业务洞察
2. **技术价值**: 建立可扩展的事件驱动架构
3. **运维价值**: 提供全面的系统监控和故障排查能力
4. **合规价值**: 满足审计和数据合规要求

这个实施计划确保了项目的有序进行，通过分阶段实施降低风险，同时保证系统的稳定性和可靠性。

---

## 📋 当前实施状态 (2024-01-15)

### ✅ 已完成的核心功能

1. **审计服务核心组件**

   - ✅ `ChargingAuditService` - 充电流程审计服务
   - ✅ `RedisAuditStorage` - Redis 存储实现（复用现有 Redis）
   - ✅ `MemorySessionCache` - 内存会话缓存
   - ✅ `MetricsCollector` - 指标收集器

2. **通知管理核心组件**

   - ✅ `NotificationManager` - 第三方平台通知管理器
   - ✅ 支持 HTTP 端点通知
   - ✅ 重试机制和死信队列

3. **系统集成**
   - ✅ 集成到现有 `configs/gateway.yaml` 配置
   - ✅ 复用现有 Redis 客户端，避免资源浪费
   - ✅ `AuditManager` 统一管理器
   - ✅ 配置转换适配器

### 🔧 关键改进

- **避免重复资源**: 删除了独立的 Redis 配置，复用现有连接
- **统一配置管理**: 集成到现有配置文件，避免配置分散
- **渐进式启用**: 默认关闭，通过配置启用，不影响现有系统
- **轻量级集成**: 最小化对现有系统的影响

### 📂 文件结构

```
pkg/audit/
├── types.go              # 核心数据结构
├── interfaces.go         # 接口定义
├── config.go            # 配置结构
├── config_adapter.go    # 配置转换适配器
├── service.go           # 审计服务实现
├── redis_storage.go     # Redis存储实现
├── notification_manager.go # 通知管理器
├── session_cache.go     # 会话缓存
├── metrics.go           # 指标收集器
└── integration_example.go # 集成示例
```

### 🎯 下一步工作

1. **协议处理器集成** - 在现有 Handler 中添加审计调用
2. **API 接口集成** - 在 HTTP API 中添加审计功能
3. **测试验证** - 编写单元测试和集成测试
4. **文档完善** - 更新 API 文档和使用指南

### 💡 使用示例

```go
// 在main.go中初始化
auditManager, err := audit.NewAuditManager()
if err != nil {
    log.Fatal(err)
}

// 启动审计服务
if err := auditManager.Start(ctx); err != nil {
    log.Fatal(err)
}

// 在协议处理器中使用
auditManager.RecordDeviceOnline(deviceID, data)
auditManager.RecordStatusChange(deviceID, port, oldStatus, newStatus)
```

**状态**: ✅ 核心功能已完成，协议处理器集成已完成，系统可以投入使用。

### 🚀 快速启用指南

1. **启用审计功能**

```yaml
# configs/gateway.yaml
audit:
  enabled: true # 设置为true启用审计
```

2. **在主程序中初始化**

```go
// 在main.go中添加
import "github.com/bujia-iot/iot-zinx/pkg/audit"

func main() {
    // 初始化审计系统
    if err := audit.InitGlobalHandlerIntegrator(); err != nil {
        log.Fatal(err)
    }
    defer audit.StopGlobalHandlerIntegrator()

    // 其他初始化代码...
}
```

3. **在协议处理器中集成**

```go
// 在现有处理器中添加审计功能
type YourHandler struct {
    auditIntegrator *audit.HandlerIntegrator
}

func (h *YourHandler) Handle(request ziface.IRequest) {
    // 原有处理逻辑...

    // 添加审计记录
    h.auditIntegrator.RecordProtocolEvent("your_event_type", decodedFrame, conn, eventData)
}
```

### 📊 系统能力

- ✅ **实时审计**: 所有设备操作实时记录
- ✅ **故障排查**: 完整的事件时间线
- ✅ **业务分析**: 充电数据统计分析
- ✅ **合规审计**: 满足监管要求
- ✅ **性能监控**: 系统性能实时监控
- ✅ **第三方通知**: 支持业务平台集成
- ✅ **数据保留**: 智能 TTL 管理，节省存储成本
